# Web 技术总结

## 1. 基础概念

### 1.1 什么是 Web
Web（World Wide Web）是一个通过互联网访问的、由相互链接的超文本组成的信息系统。它使用 HTTP 协议进行通信，通过浏览器访问网站。

### 1.2 Web 应用架构

#### 1.2.1 客户端-服务器架构
- **客户端**：用户使用的浏览器，负责发送请求和显示响应
- **服务器**：处理客户端请求，返回响应数据
- **通信协议**：HTTP/HTTPS

#### 1.2.2 常见 Web 架构模式
- **三层架构**：表示层、业务逻辑层、数据访问层
- **MVC 模式**：模型（Model）、视图（View）、控制器（Controller）
- **前后端分离架构**：前端负责界面展示，后端提供 API 服务
- **微服务架构**：将应用拆分为多个独立的微服务

### 1.3 HTTP 协议基础

#### 1.3.1 HTTP 概述
HTTP（HyperText Transfer Protocol）是一种用于分布式、协作式和超媒体信息系统的应用层协议。它是 Web 应用的基础，定义了客户端与服务器之间的通信规则。

#### 1.3.2 HTTP 版本
- **HTTP/1.0**：每次请求都需要建立新的 TCP 连接
- **HTTP/1.1**：支持持久连接、管道化请求、分块传输编码
- **HTTP/2**：支持多路复用、服务器推送、头部压缩
- **HTTP/3**：基于 QUIC 协议，提供更低的延迟和更好的多路复用

#### 1.3.3 HTTP 消息结构

**请求消息**：
```
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0
Accept: text/html
```

**响应消息**：
```
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 1024

<!DOCTYPE html>
<html>
<body>
<h1>Hello World</h1>
</body>
</html>
```

## 2. 核心技术

### 2.1 HTTP 方法

#### 2.1.1 常用 HTTP 方法
| 方法 | 描述 | 安全性 | 幂等性 |
|------|------|--------|--------|
| GET | 获取资源 | 安全 | 幂等 |
| POST | 提交数据，创建资源 | 不安全 | 非幂等 |
| PUT | 更新资源 | 不安全 | 幂等 |
| DELETE | 删除资源 | 不安全 | 幂等 |
| HEAD | 获取资源头部信息 | 安全 | 幂等 |
| OPTIONS | 获取服务器支持的方法 | 安全 | 幂等 |
| PATCH | 部分更新资源 | 不安全 | 非幂等 |

#### 2.1.2 GET 与 POST 的区别
1. **请求参数**：GET 参数在 URL 中，POST 参数在请求体中
2. **长度限制**：GET 有长度限制（约 2048 字符），POST 没有
3. **安全性**：GET 参数暴露在 URL 中，POST 相对安全
4. **缓存**：GET 请求可缓存，POST 请求不可缓存
5. **历史记录**：GET 请求会被浏览器保存到历史记录，POST 不会
6. **书签**：GET 请求可被收藏为书签，POST 不可

### 2.2 Session 与 Cookie

#### 2.2.1 Cookie
- **定义**：Cookie 是服务器发送给客户端的小型文本文件，存储在客户端
- **作用**：跟踪用户会话、存储用户偏好设置、实现记住登录状态
- **特点**：
  - 大小限制：通常 4KB
  - 数量限制：每个域名下最多 50 个
  - 过期时间：可设置，默认为会话结束
  - 安全性：可设置 HttpOnly、Secure、SameSite 属性

#### 2.2.2 Session
- **定义**：Session 是服务器端存储用户会话信息的机制
- **作用**：存储用户会话状态、管理用户登录信息
- **特点**：
  - 存储在服务器端，更安全
  - 大小限制较小
  - 过期时间：可设置，默认为 30 分钟
  - 依赖 Cookie：通常通过 Cookie 存储 Session ID

#### 2.2.3 Session 与 Cookie 的区别
| 特性 | Session | Cookie |
|------|---------|--------|
| 存储位置 | 服务器端 | 客户端 |
| 安全性 | 较高 | 较低 |
| 存储大小 | 较大 | 较小（约 4KB） |
| 过期时间 | 服务器控制 | 可设置，默认为会话结束 |
| 网络传输 | 仅传输 Session ID | 每次请求都传输 |
| 依赖关系 | 依赖 Cookie 存储 Session ID | 独立 |

### 2.3 Servlet 技术

#### 2.3.1 Servlet 概述
Servlet 是 Java 编写的服务器端程序，用于处理客户端请求并生成响应。它运行在 Servlet 容器中（如 Tomcat）。

#### 2.3.2 Servlet 生命周期
1. **加载**：当 Servlet 第一次被请求时，或服务器启动时（如果配置了 `load-on-startup`），容器加载 Servlet 类
2. **初始化**：调用 `init(ServletConfig)` 方法，只执行一次
3. **服务**：每次请求到达时，调用 `service(ServletRequest, ServletResponse)` 方法
4. **销毁**：当 Web 应用被卸载或服务器关闭时，调用 `destroy()` 方法

#### 2.3.3 Servlet 核心接口与类
- `Servlet`：核心接口，定义了 Servlet 的基本方法
- `GenericServlet`：抽象类，实现了 Servlet 接口的大部分方法
- `HttpServlet`：抽象类，继承自 GenericServlet，专门处理 HTTP 请求

### 2.4 转发与重定向

#### 2.4.1 转发（Forward）
- **定义**：服务器内部将请求从一个 Servlet 转发到另一个资源
- **实现**：使用 `RequestDispatcher.forward()` 方法
- **特点**：
  - 发生在服务器端
  - 浏览器地址栏不变
  - 只产生一次请求
  - 可以共享请求域中的数据
  - 只能转发到同一 Web 应用内的资源

#### 2.4.2 重定向（Redirect）
- **定义**：服务器返回 302 状态码，指示浏览器向新的 URL 发送请求
- **实现**：使用 `HttpServletResponse.sendRedirect()` 方法
- **特点**：
  - 发生在客户端
  - 浏览器地址栏会改变
  - 产生两次请求
  - 不能共享请求域中的数据
  - 可以重定向到任意 URL

#### 2.4.3 转发与重定向的区别
| 特性 | 转发 | 重定向 |
|------|------|--------|
| 发生位置 | 服务器端 | 客户端 |
| 浏览器地址 | 不变 | 改变 |
| 请求次数 | 一次 | 两次 |
| 数据共享 | 可共享请求域数据 | 不可共享请求域数据 |
| 适用场景 | 同一应用内页面跳转 | 跨应用页面跳转、避免表单重复提交 |
| URL 限制 | 只能是相对路径 | 可以是绝对路径 |

### 2.5 长连接与短连接

#### 2.5.1 短连接
- **定义**：每次请求都建立新的 TCP 连接，请求完成后关闭连接
- **特点**：
  - 连接建立和关闭的开销较大
  - 适用于请求频率低的场景
  - HTTP/1.0 默认使用短连接

#### 2.5.2 长连接
- **定义**：建立一次 TCP 连接后，多次请求复用该连接
- **特点**：
  - 减少连接建立和关闭的开销
  - 适用于请求频率高的场景
  - HTTP/1.1 默认使用长连接
  - 需要设置合理的连接超时时间

#### 2.5.3 长连接与短连接的区别
| 特性 | 短连接 | 长连接 |
|------|--------|--------|
| 连接生命周期 | 一次请求 | 多次请求 |
| 连接开销 | 较大 | 较小 |
| 资源占用 | 较低 | 较高 |
| 适用场景 | 请求频率低 | 请求频率高 |
| 默认协议 | HTTP/1.0 | HTTP/1.1 |

### 2.6 Web 安全基础

#### 2.6.1 常见 Web 安全漏洞
- **SQL 注入**：通过输入特殊字符，操纵数据库查询
- **XSS（跨站脚本攻击）**：注入恶意脚本，在用户浏览器中执行
- **CSRF（跨站请求伪造）**：诱导用户在已登录的情况下执行非预期操作
- **会话固定**：利用固定的会话 ID 进行攻击
- **敏感信息泄露**：未加密的敏感数据被窃取
- **文件上传漏洞**：上传恶意文件到服务器

#### 2.6.2 安全防护措施
- **输入验证**：对所有用户输入进行验证和过滤
- **输出编码**：对输出到浏览器的数据进行编码
- **使用 HTTPS**：加密传输数据
- **设置安全头部**：如 Content-Security-Policy、X-XSS-Protection
- **使用参数化查询**：防止 SQL 注入
- **实现 CSRF 令牌**：防止 CSRF 攻击
- **安全的密码存储**：使用加盐哈希存储密码
- **定期安全审计**：检查代码和配置中的安全漏洞

## 3. 架构设计

### 3.1 三层架构
- **表示层（Presentation Layer）**：负责用户界面和用户交互
- **业务逻辑层（Business Logic Layer）**：负责处理业务逻辑
- **数据访问层（Data Access Layer）**：负责与数据库交互

### 3.2 MVC 模式
- **模型（Model）**：表示应用程序的数据和业务逻辑
- **视图（View）**：负责展示数据给用户
- **控制器（Controller）**：处理用户输入，调用模型，更新视图

### 3.3 RESTful API 设计

#### 3.3.1 REST 原则
- **资源**：使用 URI 标识资源
- **统一接口**：使用标准的 HTTP 方法
- **无状态**：服务器不存储客户端状态
- **缓存**：支持缓存机制
- **分层系统**：支持分层架构
- **按需编码**：可选，允许服务器向客户端发送可执行代码

#### 3.3.2 RESTful API 设计最佳实践
- **使用合适的 HTTP 方法**：GET 获取资源，POST 创建资源，PUT 更新资源，DELETE 删除资源
- **使用清晰的 URI**：如 `/api/users/{id}`
- **使用合适的状态码**：如 200 OK，201 Created，400 Bad Request，404 Not Found
- **使用 JSON 作为数据格式**：统一使用 JSON 进行数据交换
- **实现版本控制**：如 `/api/v1/users`
- **添加适当的错误处理**：返回详细的错误信息

### 3.4 前后端分离架构

#### 3.4.1 架构特点
- **前端**：负责界面展示和用户交互，使用 React、Vue、Angular 等框架
- **后端**：提供 API 服务，处理业务逻辑和数据存储
- **通信**：通过 HTTP/HTTPS 协议和 JSON 格式进行通信

#### 3.4.2 前后端分离的优势
- **开发效率高**：前后端可并行开发
- **用户体验好**：前端可实现更丰富的交互效果
- **系统可维护性强**：职责清晰，易于扩展
- **技术选型灵活**：前后端可使用不同的技术栈

## 4. 性能优化

### 4.1 前端优化
- **减少 HTTP 请求**：合并文件、使用 CSS Sprites
- **优化资源加载**：使用 CDN、启用缓存、压缩文件
- **延迟加载**：图片懒加载、按需加载 JavaScript
- **优化 CSS 和 JavaScript**：减少选择器复杂度、避免 DOM 操作阻塞
- **使用浏览器缓存**：设置合理的缓存策略
- **减少重排和重绘**：优化 DOM 操作

### 4.2 后端优化
- **优化代码**：减少不必要的计算和数据库查询
- **使用缓存**：如 Redis、Memcached
- **优化数据库**：使用索引、优化查询语句
- **使用连接池**：如数据库连接池、HTTP 连接池
- **异步处理**：使用消息队列处理耗时操作
- **负载均衡**：分发请求到多个服务器

### 4.3 数据库优化
- **设计合理的数据库结构**：范式设计，适当反范式
- **使用索引**：为常用查询字段创建索引
- **优化查询语句**：避免全表扫描，使用分页
- **分库分表**：处理大数据量
- **读写分离**：提高并发处理能力
- **定期维护**：清理碎片，更新统计信息

### 4.4 缓存策略
- **浏览器缓存**：设置 HTTP 缓存头部
- **CDN 缓存**：使用内容分发网络
- **应用缓存**：如 Redis、Memcached
- **数据库缓存**：数据库查询缓存
- **多级缓存**：组合使用多种缓存策略

## 5. 部署与运维

### 5.1 Web 服务器配置

#### 5.1.1 常见 Web 服务器
- **Nginx**：高性能、轻量级，适合静态资源和反向代理
- **Apache**：功能丰富，模块众多，稳定可靠
- **IIS**：微软产品，与 Windows 集成良好
- **Tomcat**：Java Web 应用服务器，支持 Servlet 和 JSP

#### 5.1.2 服务器配置优化
- **调整线程池**：根据服务器硬件和流量设置合适的线程数
- **启用压缩**：压缩静态资源，减少传输大小
- **配置缓存**：设置静态资源的缓存时间
- **启用 HTTPS**：配置 SSL 证书，加密传输
- **限制请求**：防止 DDoS 攻击，设置请求速率限制

### 5.2 负载均衡

#### 5.2.1 负载均衡策略
- **轮询**：依次分发请求到服务器
- **加权轮询**：根据服务器性能分配权重
- **IP 哈希**：根据客户端 IP 分配服务器，保证会话一致性
- **最少连接**：将请求分发到当前连接数最少的服务器
- **响应时间**：将请求分发到响应时间最短的服务器

#### 5.2.2 负载均衡实现
- **硬件负载均衡**：如 F5、Citrix NetScaler
- **软件负载均衡**：如 Nginx、HAProxy、LVS
- **云服务负载均衡**：如 AWS ELB、阿里云 SLB

### 5.3 集群部署

#### 5.3.1 集群架构
- **水平扩展**：增加服务器数量，提高处理能力
- **垂直扩展**：提升单个服务器的硬件配置
- **会话共享**：使用 Redis、数据库等存储会话信息
- **数据同步**：确保集群中数据的一致性

#### 5.3.2 高可用方案
- **主备模式**：主服务器故障时，备服务器接管
- **集群模式**：多台服务器同时提供服务，单点故障不影响整体
- **健康检查**：定期检查服务器状态，及时发现故障
- **自动故障转移**：故障发生时自动切换到健康服务器

### 5.4 监控与日志

#### 5.4.1 监控指标
- **系统指标**：CPU、内存、磁盘、网络使用情况
- **应用指标**：响应时间、请求量、错误率
- **数据库指标**：查询响应时间、连接数、慢查询
- **业务指标**：交易量、用户数、转化率

#### 5.4.2 监控工具
- **系统监控**：Zabbix、Prometheus、Grafana
- **应用监控**：New Relic、Datadog、AppDynamics
- **日志分析**：ELK Stack（Elasticsearch、Logstash、Kibana）、Graylog

## 6. 面试题解析

### 6.1 常见 Web 开发面试题

#### 6.1.1 HTTP 状态码有哪些？分别代表什么含义？
**答案**：
HTTP 状态码分为 5 类：

- **1xx（信息性状态码）**：
  - 100 Continue：服务器已收到请求头，客户端应继续发送请求体
  - 101 Switching Protocols：服务器同意切换协议

- **2xx（成功状态码）**：
  - 200 OK：请求成功
  - 201 Created：请求成功并创建了新资源
  - 202 Accepted：请求已接受，但尚未处理完成
  - 204 No Content：请求成功，但没有响应体

- **3xx（重定向状态码）**：
  - 301 Moved Permanently：资源永久移动到新位置
  - 302 Found：资源临时移动到新位置
  - 304 Not Modified：资源未修改，使用缓存

- **4xx（客户端错误状态码）**：
  - 400 Bad Request：请求参数错误
  - 401 Unauthorized：未授权，需要身份验证
  - 403 Forbidden：服务器拒绝访问
  - 404 Not Found：资源不存在
  - 405 Method Not Allowed：请求方法不被允许

- **5xx（服务器错误状态码）**：
  - 500 Internal Server Error：服务器内部错误
  - 501 Not Implemented：服务器不支持该功能
  - 502 Bad Gateway：网关错误
  - 503 Service Unavailable：服务不可用
  - 504 Gateway Timeout：网关超时

#### 6.1.2 如何实现跨域请求？
**答案**：
实现跨域请求的方法有：

1. **CORS（跨域资源共享）**：
   - 服务器端设置响应头部：`Access-Control-Allow-Origin`
   - 支持预检请求（OPTIONS）
   - 可设置允许的方法、头部、凭证等

2. **JSONP**：
   - 利用 `<script>` 标签的跨域特性
   - 服务器返回包装在函数调用中的 JSON 数据
   - 只支持 GET 请求

3. **代理服务器**：
   - 在同源服务器上设置代理，转发请求到目标服务器
   - 适用于所有请求方法

4. **WebSocket**：
   - 建立持久连接，支持跨域
   - 适用于实时通信场景

5. **postMessage**：
   - HTML5 API，允许不同源的窗口之间通信
   - 适用于窗口间通信

#### 6.1.3 什么是 RESTful API？如何设计一个 RESTful API？
**答案**：
RESTful API 是遵循 REST 架构风格的 API 设计。REST（Representational State Transfer）是一种软件架构风格，定义了一组约束和属性，用于创建 Web 服务。

设计 RESTful API 的最佳实践：

1. **使用合适的 HTTP 方法**：
   - GET：获取资源
   - POST：创建资源
   - PUT：更新资源
   - DELETE：删除资源
   - PATCH：部分更新资源

2. **使用清晰的 URI**：
   - 使用名词表示资源，如 `/users`、`/products`
   - 使用复数形式表示资源集合
   - 使用路径参数表示单个资源，如 `/users/{id}`
   - 避免使用动词，如 `/getUsers`

3. **使用合适的 HTTP 状态码**：
   - 200 OK：请求成功
   - 201 Created：资源创建成功
   - 204 No Content：请求成功但无响应体
   - 400 Bad Request：请求参数错误
   - 404 Not Found：资源不存在
   - 500 Internal Server Error：服务器内部错误

4. **返回一致的格式**：
   - 使用 JSON 作为默认数据格式
   - 包含必要的元数据，如分页信息
   - 错误响应应包含错误代码和消息

5. **实现版本控制**：
   - 在 URI 中包含版本号，如 `/api/v1/users`
   - 或使用请求头指定版本

6. **处理认证和授权**：
   - 使用 OAuth 2.0 或 JWT 进行认证
   - 实现基于角色的访问控制

7. **支持过滤、排序和分页**：
   - 使用查询参数进行过滤，如 `/users?status=active`
   - 使用查询参数进行排序，如 `/users?sort=name`
   - 使用查询参数进行分页，如 `/users?page=1&limit=10`

#### 6.1.4 如何防止 XSS 攻击？
**答案**：
防止 XSS 攻击的措施：

1. **输入验证**：
   - 对所有用户输入进行验证和过滤
   - 限制输入长度和格式
   - 移除或转义特殊字符

2. **输出编码**：
   - 对输出到浏览器的数据进行 HTML 编码
   - 使用安全的模板引擎，自动进行输出编码
   - 对 JavaScript、CSS、URL 等特殊上下文进行相应的编码

3. **使用内容安全策略（CSP）**：
   - 通过 HTTP 头部设置 `Content-Security-Policy`
   - 限制可执行脚本的来源
   - 禁止内联脚本和 eval() 函数

4. **设置 HttpOnly 标志**：
   - 为 Cookie 设置 HttpOnly 属性
   - 防止 JavaScript 访问 Cookie

5. **使用现代框架**：
   - 现代前端框架（如 React、Vue、Angular）内置了 XSS 防护
   - 遵循框架的安全最佳实践

6. **定期安全审计**：
   - 使用安全扫描工具检测 XSS 漏洞
   - 定期更新依赖库，修复已知漏洞

#### 6.1.5 什么是 CSRF 攻击？如何防止？
**答案**：
CSRF（Cross-Site Request Forgery，跨站请求伪造）是一种攻击方式，攻击者诱导用户在已登录的情况下执行非预期的操作。

防止 CSRF 攻击的措施：

1. **使用 CSRF 令牌**：
   - 服务器为每个会话生成唯一的 CSRF 令牌
   - 将令牌嵌入到表单中或存储在 Cookie 中
   - 客户端提交请求时携带令牌
   - 服务器验证令牌的有效性

2. **验证 Referer 和 Origin 头部**：
   - 检查请求的 Referer 和 Origin 头部
   - 确保请求来自合法的来源

3. **使用 SameSite Cookie 属性**：
   - 设置 Cookie 的 SameSite 属性为 Strict 或 Lax
   - 防止跨站请求携带 Cookie

4. **实现双重提交防护**：
   - 将 CSRF 令牌同时存储在 Cookie 和表单中
   - 服务器验证两者是否匹配

5. **使用验证码**：
   - 对于敏感操作，要求用户输入验证码
   - 增加攻击的难度

6. **保持会话管理安全**：
   - 使用安全的会话管理机制
   - 及时过期会话
   - 实现会话固定保护

#### 6.1.6 如何优化 Web 应用的性能？
**答案**：
优化 Web 应用性能的措施：

1. **前端优化**：
   - 减少 HTTP 请求：合并文件、使用 CSS Sprites
   - 优化资源加载：使用 CDN、启用缓存、压缩文件
   - 延迟加载：图片懒加载、按需加载 JavaScript
   - 优化 CSS 和 JavaScript：减少选择器复杂度、避免 DOM 操作阻塞
   - 使用浏览器缓存：设置合理的缓存策略
   - 减少重排和重绘：优化 DOM 操作
   - 使用现代前端框架：React、Vue、Angular 等

2. **后端优化**：
   - 优化代码：减少不必要的计算和数据库查询
   - 使用缓存：如 Redis、Memcached
   - 优化数据库：使用索引、优化查询语句
   - 使用连接池：如数据库连接池、HTTP 连接池
   - 异步处理：使用消息队列处理耗时操作
   - 负载均衡：分发请求到多个服务器
   - 使用适当的编程语言和框架：根据场景选择合适的技术栈

3. **数据库优化**：
   - 设计合理的数据库结构：范式设计，适当反范式
   - 使用索引：为常用查询字段创建索引
   - 优化查询语句：避免全表扫描，使用分页
   - 分库分表：处理大数据量
   - 读写分离：提高并发处理能力
   - 定期维护：清理碎片，更新统计信息

4. **服务器优化**：
   - 调整服务器配置：根据硬件和流量设置合适的参数
   - 启用压缩：压缩静态资源，减少传输大小
   - 配置缓存：设置静态资源的缓存时间
   - 启用 HTTPS：配置 SSL 证书，加密传输
   - 限制请求：防止 DDoS 攻击，设置请求速率限制

5. **架构优化**：
   - 使用微服务架构：拆分大型应用为小型服务
   - 实现水平扩展：增加服务器数量，提高处理能力
   - 使用 CDN：分发静态资源，减少服务器负载
   - 采用前后端分离：提高开发效率和用户体验
   - 实现多级缓存：组合使用多种缓存策略

#### 6.1.7 什么是 HTTPS？它与 HTTP 有什么区别？
**答案**：
HTTPS（HyperText Transfer Protocol Secure）是 HTTP 的安全版本，通过 SSL/TLS 协议提供加密通信和身份验证。

HTTPS 与 HTTP 的区别：

| 特性 | HTTP | HTTPS |
|------|------|-------|
| 安全性 | 明文传输，不安全 | 加密传输，安全 |
| 默认端口 | 80 | 443 |
| 协议头 | HTTP/1.1、HTTP/2 | HTTPS/1.1、HTTPS/2 |
| 证书 | 不需要 | 需要 SSL/TLS 证书 |
| 性能 | 较快 | 较慢（加密解密开销） |
| 搜索排名 | 无影响 | 有利于 SEO |
| 浏览器显示 | 无特殊标识 | 显示锁图标和 "https://" |

HTTPS 的工作原理：
1. 客户端发送 HTTPS 请求到服务器
2. 服务器返回 SSL/TLS 证书给客户端
3. 客户端验证证书的有效性
4. 客户端和服务器协商加密算法和会话密钥
5. 客户端使用会话密钥加密数据，发送给服务器
6. 服务器使用会话密钥解密数据，处理请求
7. 服务器使用会话密钥加密响应，发送给客户端
8. 客户端使用会话密钥解密响应，显示结果

#### 6.1.8 什么是 CDN？它的工作原理是什么？
**答案**：
CDN（Content Delivery Network，内容分发网络）是一组分布在不同地理位置的服务器，用于存储静态资源的副本，以提高资源的访问速度和网站的可用性。

CDN 的工作原理：

1. **资源存储**：网站将静态资源（如图片、CSS、JavaScript 文件）上传到 CDN
2. **资源分发**：CDN 将资源复制到分布在全球各地的边缘节点
3. **用户请求**：用户请求访问网站的静态资源
4. **DNS 解析**：DNS 将用户的请求解析到最近的 CDN 边缘节点
5. **资源获取**：
   - 如果边缘节点有资源缓存，直接返回给用户
   - 如果边缘节点没有资源缓存，从源站获取资源，缓存后返回给用户
6. **缓存更新**：当源站的资源更新时，CDN 会更新边缘节点的缓存

CDN 的优势：
- **提高访问速度**：用户从最近的边缘节点获取资源
- **减轻源站负载**：大部分静态资源请求由 CDN 处理
- **提高可用性**：即使源站故障，CDN 仍能提供缓存的资源
- **防御 DDoS 攻击**：分散流量，减轻源站压力
- **降低带宽成本**：减少长距离传输的带宽消耗

#### 6.1.9 什么是浏览器缓存？如何设置？
**答案**：
浏览器缓存是浏览器存储静态资源的机制，当用户再次访问相同资源时，直接从缓存中获取，而不需要重新下载，从而提高页面加载速度和减少网络流量。

浏览器缓存的设置方法：

1. **HTTP 缓存头部**：
   - **Cache-Control**：控制缓存行为，如 `max-age`（缓存时间）、`public`/`private`（缓存范围）、`no-cache`（强制验证）、`no-store`（禁止缓存）
   - **Expires**：指定缓存过期时间（HTTP/1.0）
   - **Last-Modified**：资源最后修改时间
   - **ETag**：资源的唯一标识

2. **缓存验证**：
   - **If-Modified-Since**：与 Last-Modified 配合使用，检查资源是否修改
   - **If-None-Match**：与 ETag 配合使用，检查资源是否变化

3. **缓存策略**：
   - **强缓存**：直接从缓存中获取资源，不发送请求到服务器
   - **协商缓存**：发送请求到服务器，验证资源是否变化，未变化则使用缓存

4. **实际应用**：
   - 对于频繁变化的资源：设置较短的缓存时间或使用协商缓存
   - 对于不常变化的资源：设置较长的缓存时间，使用版本号或哈希值作为文件名
   - 对于静态资源：启用压缩，设置合理的缓存时间

#### 6.1.10 什么是 WebSocket？它与 HTTP 有什么区别？
**答案**：
WebSocket 是一种网络通信协议，提供全双工、持久的连接，允许服务器和客户端之间进行实时双向通信。

WebSocket 与 HTTP 的区别：

| 特性 | HTTP | WebSocket |
|------|------|-----------|
| 连接类型 | 半双工，短连接 | 全双工，长连接 |
| 通信方向 | 客户端发起请求，服务器响应 | 双向通信，服务器可主动推送 |
| 协议头 | HTTP/1.1、HTTP/2 | ws://、wss:// |
| 默认端口 | 80、443 | 80、443（与 HTTP 相同） |
| 握手过程 | 简单的请求-响应 | 基于 HTTP 的握手，然后升级到 WebSocket |
| 数据格式 | 文本、二进制 | 文本、二进制 |
| 适用场景 | 传统 Web 应用 | 实时通信应用（聊天、游戏、监控等） |
| 开销 | 每次请求都有 HTTP 头部开销 | 仅握手时有 HTTP 头部开销，后续通信开销小 |

WebSocket 的工作原理：
1. 客户端发送 HTTP 请求到服务器，包含 `Upgrade: websocket` 头部
2. 服务器响应 `101 Switching Protocols`，表示同意升级到 WebSocket 协议
3. 连接建立，客户端和服务器可以通过该连接进行实时双向通信
4. 通信结束后，客户端或服务器关闭连接

WebSocket 的优势：
- **实时性**：服务器可以主动推送数据给客户端
- **低延迟**：避免了 HTTP 请求的头部开销和连接建立时间
- **减少带宽**：不需要重复发送相同的头部信息
- **简化编程模型**：不需要轮询或长轮询

## 7. 参考链接

### 7.1 官方文档
- [HTTP 规范](https://tools.ietf.org/html/rfc7230)
- [Mozilla Web 开发文档](https://developer.mozilla.org/en-US/docs/Web)
- [W3C Web 标准](https://www.w3.org/standards/)
- [Servlet 规范](https://jakarta.ee/specifications/servlet/)

### 7.2 教程资源
- [MDN Web 开发教程](https://developer.mozilla.org/en-US/docs/Learn)
- [W3Schools Web 教程](https://www.w3schools.com/)
- [Java Web 开发教程](https://www.tutorialspoint.com/servlets/)
- [前端开发教程](https://www.freecodecamp.org/learn/)

### 7.3 博客文章
- [HTTP 协议详解](https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview)
- [RESTful API 设计最佳实践](https://restfulapi.net/)
- [Web 性能优化指南](https://developers.google.com/web/fundamentals/performance)
- [Web 安全最佳实践](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)
- [CDN 工作原理](https://www.cloudflare.com/learning/cdn/what-is-a-cdn/)

### 7.4 视频教程
- [Web 开发基础](https://www.coursera.org/learn/web-development)
- [HTTP/2 与 WebSocket](https://www.udemy.com/course/http2-the-definitive-guide/)
- [Web 安全实战](https://www.udemy.com/course/web-security-fundamentals/)
- [性能优化实战](https://www.udemy.com/course/website-performance-optimization/)

### 7.5 工具与资源
- [Postman](https://www.postman.com/)：API 测试工具
- [Chrome DevTools](https://developers.google.com/web/tools/chrome-devtools)：浏览器开发工具
- [Wireshark](https://www.wireshark.org/)：网络协议分析工具
- [SecurityHeaders.com](https://securityheaders.com/)：安全头部检测工具
- [GTmetrix](https://gtmetrix.com/)：网站性能分析工具
