# study-JVM

## 简介

主要说： HotSpot JVM

## JVM背景与历史

### 发展历程

JVM（Java Virtual Machine）的历史可以追溯到1990年代初，当时Sun Microsystems公司的James Gosling领导的团队开始开发一种名为"Green Project"的编程语言，旨在为消费电子产品创建一种可移植的编程解决方案。

1. **1991年**：Green Project启动，开发了一种名为Oak的编程语言，这是Java的前身。

2. **1995年**：Sun正式发布Java 1.0，同时推出了JVM规范。JVM的设计理念是"一次编写，到处运行"（Write Once, Run Anywhere），通过将Java代码编译为字节码，然后由不同平台上的JVM解释执行，实现了跨平台兼容性。

3. **1997年**：Java 1.1发布，引入了JIT（Just-In-Time）编译器，显著提高了Java程序的执行效率。

4. **2000年**：Java 2平台发布，包括J2SE、J2EE和J2ME三个版本，JVM也得到了相应的增强。

5. **2006年**：Sun宣布Java技术开源，成立了OpenJDK项目，JVM的开发开始由社区共同参与。

6. **2009年**：Oracle收购Sun Microsystems，成为Java和JVM的新所有者。

7. **2014年**：Java 8发布，引入了Lambda表达式、Stream API等重要特性，同时JVM在性能和垃圾回收方面也有了显著改进。

8. **2018年**：Java 11发布，这是第一个长期支持（LTS）版本，同时引入了ZGC等新的垃圾回收器。

9. **2021年**：Java 17发布，这是最新的LTS版本，进一步增强了JVM的性能和功能。

### 技术演进

JVM的技术演进主要体现在以下几个方面：

1. **执行引擎优化**：从最初的纯解释执行，到引入JIT编译器，再到分层编译（Tiered Compilation），不断提高Java程序的执行效率。

2. **内存管理改进**：从早期的简单内存模型，到分代收集，再到G1、ZGC等先进的垃圾回收器，内存管理的效率和可靠性不断提升。

3. **并发处理增强**：引入了更高效的并发数据结构和同步机制，支持更大规模的并发应用。

4. **安全性提升**：不断加强JVM的安全机制，防止恶意代码的执行。

5. **工具链完善**：提供了丰富的监控、诊断和调优工具，如JConsole、VisualVM、JMC等，帮助开发者更好地理解和优化JVM的运行状态。

### 重要的JVM实现

除了Oracle的HotSpot JVM外，还有其他一些重要的JVM实现：

1. **OpenJ9**：由IBM开发，后捐赠给Eclipse基金会，以低内存占用和快速启动著称。

2. **GraalVM**：Oracle开发的高性能运行时，支持多种语言，包括Java、JavaScript、Python等。

3. **Azul Zing**：Azul Systems开发的商业JVM，专注于低延迟应用场景。

4. **BEA JRockit**：曾经由BEA Systems开发，后被Oracle收购，以高性能和低延迟著称，最终被整合到HotSpot中。

## Key关键点

- 行业调研、优势、代替方案等
- 架构
- 类加载过程
- 触发类加载
- 类加载顺序
- JVM 虚拟机各种类型
- 参数含义【核心参数、调优】
- 命令行工具
- 可视化工具
- JVM 调优
- JVM 常用参数 
- GC 触发场景和条件【验证GC 过程 】
- 频繁GC的场景
- Full GC 优化
- 内存泄露监控
- 对象头信息
- OOM 场景和处理过程 
- 内存分配
- 三色标记
- 安全点 safepoint



## **概要** 



## 架构 

大概结构 

![](https://images0.cnblogs.com/i/288799/201405/281726404166686.jpg)

### 常用组件 

https://blog.csdn.net/qq_51330350/article/details/127538316

https://www.cnblogs.com/dolphin0520/p/3613043.html

#### 程序计数器

　　程序计数器（Program Counter Register），保存程序当前执行的指令的地址，当CPU需要执行指令时，需要从程序计数器中得到当前需要执行的指令所在存储单元的地址，然后根据得到的地址获取到指令，在得到指令之后，程序计数器便自动加1或者根据转移指针得到下一条指令的地址，如此循环，直至执行完所有的指令。

　　在JVM规范中规定，如果线程执行的是非native方法，则程序计数器中保存的是当前需要执行的指令的地址；如果线程执行的是native方法，则程序计数器中的值是undefined。

　　由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，因此，对于程序计数器是不会发生内存溢出现象(OutOfMemory)的。



#### Java栈

　　Java栈也称作虚拟机栈（Java Vitual Machine Stack），也就是我们常常所说的栈，跟C语言的数据段中的栈类似。事实上，Java栈是Java方法执行的内存模型。

　　Java栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法，在栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、指向当前方法所属的类的运行时常量池（运行时常量池的概念在方法区部分会谈到）的引用(Reference to runtime constant pool)、方法返回地址(Return Address)和一些额外的附加信息。

​		当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。因此可知，线程当前执行的方法所对应的栈帧必定位于Java栈的顶部。，这部分空间的分配和释放都是由系统自动实施的。

![](https://images0.cnblogs.com/i/288799/201405/291429030562182.jpg)



![](https://img-blog.csdnimg.cn/ce4717358430466fb5d122342cd540aa.png)

#### 本地方法栈

　　本地方法栈与Java栈的作用和原理非常相似。区别只不过是Java栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法（Native Method）服务的。

​		在JVM规范中，并没有对本地方发展的具体实现方法以及数据结构作强制规定，虚拟机可以自由实现它。在HotSopt虚拟机中直接就把本地方法栈和Java栈合二为一。

#### 堆

　　Java中的堆是用来存储对象本身的以及数组（当然，数组引用是存放在Java栈中的）。只不过和C语言中的不同，在Java中，程序员基本不用去关心空间释放的问题，Java的垃圾回收机制会自动进行处理。因此这部分空间也是Java垃圾收集器管理的主要区域。另外，堆是被所有线程共享的，在JVM中只有一个堆。

#### 方法区

　　方法区在JVM中也是一个非常重要的区域，它与堆一样，是被线程共享的区域。在方法区中，存储了**类信息**（包括类的名称、方法信息、字段信息）、**静态变量**、**常量**以及编译器编译后的代码等。

　　在Class文件中除了类的字段、方法、接口等描述信息外，还有一项信息是常量池，用来存储编译期间生成的字面量和符号引用。

　　在方法区中有一个非常重要的部分就是运行时常量池，它是每一个类或接口的常量池的运行时表示形式，在类和接口被加载到JVM后，对应的运行时常量池就被创建出来。当然并非Class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如String的intern方法。

　　在JVM规范中，没有强制要求方法区必须实现垃圾回收。很多人习惯将方法区称为“永久代”，是因为**HotSpot虚拟机以永久代来实现方法区**，从而JVM的垃圾收集器可以像管理堆区一样管理这部分区域，从而不需要专门为这部分设计垃圾回收机制。不过自从JDK7之后，Hotspot虚拟机便将运行时常量池从永久代移除了。



### 内存结构 

#### 堆空间 

新生代 + 老年代 

新生代 = Eden + From + To 

Eden 新生区；From 和 To 相互拷贝回收，理论上某一时刻只用到一个



## 字节码文件 

**文件结构属性**

字节码文件信息\常量池\方法表集合\类名\等等

![](https://pdai.tech/images/jvm/java-jvm-class-2.png)



**反编译工具**

输入命令查看输出内容

`javap -verbose -p Main.class` 

```

bage@bagedeMacBook-Pro bage % javac HelloTest.java 
```



## 类加载过程

https://www.cnblogs.com/fanjie/p/6916784.html

https://javaguide.cn/java/basis/java-basic-questions-01.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E8%8A%82%E7%A0%81-%E9%87%87%E7%94%A8%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88

![](https://oss.javaguide.cn/github/javaguide/java/basis/jvm-rough-structure-model.png)

**概述**

java运行过程就可以分为  编译  》 类加载  》  执行

**主要过程** 

类加载主要是由jvm虚拟机负责的，过程非常复杂，类加载分三步  加载   》  连接  》初始化

- 加载

  这个很简单，程序运行之前jvm会把编译完成的.class二进制文件加载到内存，供程序使用，用到的就是类加载器classLoader ，这里也可以看出java程序的运行并不是直接依   靠底层的操作系统，而是基于jvm虚拟机。如果没有类加载器，java文件就只是磁盘中的一个普通文件。

- 连接

  连接是很重要的一步，过程比较复杂，分为三步  验证  》准备  》解析  　　

  - 验证：确保类加载的正确性。一般情况由javac编译的class文件是不会有问题的，但是可能有人的class文件是自己通过其他方式编译出来的，这就很有可能不符合jvm的编 译规则，这一步就是要过滤掉这部分不合法文件　
  - 准备：为类的静态变量分配内存，将其初始化为默认值 。我们都知道静态变量是可以不用我们手动赋值的，它自然会有一个初始值 比如int 类型的初始值就是0 ；boolean类型初始值为false，引用类型的初始值为null 。 这里注意，只是为静态变量分配内存，此时是没有对象实例的
  - 解析：把类中的符号引用转化为直接引用。解释一下符号引用和直接引用。比如在方法A中使用方法B，A（）{B（）；}，这里的B（）就是符号引用，初学java时我们都是知道这是java的引用，以为B指向B方法的内存地址，但是这是不完整的，这里的B只是一个符号引用，它对于方法的调用没有太多的实际意义，可以这么认为，他就是给程序员看的一个标志，让程序员知道，这个方法可以这么调用，但是B方法实际调用时是通过一个指针指向B方法的内存地址，这个指针才是真正负责方法调用，他就是直接引用。

- 初始化

  为类的静态变量赋予正确的初始值，上述的准备阶段为静态变量赋予的是虚拟机默认的初始值，此处赋予的才是程序编写者为变量分配的真正的初始值



## 对象初始化

### 类加载检查

“虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程”

摘录来自: 周志明. “深入理解Java虚拟机：JVM高级特性与最佳实践。” Apple Books. 

### 分配内存

“在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定（如何确定将在2.3.2节中介绍），为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来”

摘录来自: 周志明. “深入理解Java虚拟机：JVM高级特性与最佳实践。” Apple Books. 

### 对象初始化

“在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚刚开始——＜init＞方法还没有执行，所有的字段都还为零。所以，一般来说（由字节码中是否跟随invokespecial指令所决定），执行new指令之后会接着执行＜init＞方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。”

摘录来自: 周志明. “深入理解Java虚拟机：JVM高级特性与最佳实践。” Apple Books. 



## 内存分配方式

### Bump the Pointer

“假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”（Bump the Pointer）。

### Free List

如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”（Free List）”

摘录来自: 周志明. “深入理解Java虚拟机：JVM高级特性与最佳实践。” Apple Books. 



## 参数解析

**1、** jps -v 可以查看 jvm 进程显示指定的参数

**2、** 使用 -XX:+PrintFlagsFinal 可以看到 JVM 所有参数的值

**3、** jinfo 可以实时查看和调整虚拟机各项参数

### 堆相关

-Xms【memory size】 初试堆大小 

-Xmx 【memory max】 最大堆大小

-XX:MinHeapFreeRatio 空余内存比例【增大使用】

-XX:MaxHeapFreeRatio 空余内存比如 【减少使用】 

- 堆得内存由-Xms指定，默认是物理内存的1/64；最大的内存由-Xmx指定，默认是物理内存的1/4。
-  默认空余的堆内存小于40%时，就会增大，直到-Xmx设置的内存。具体的比例可以由-XX:MinHeapFreeRatio指定
-  空余的内存大于70%时，就会减少内存，直到-Xms设置的大小。具体由-XX:MaxHeapFreeRatio指定。

–XX:NewRatio 新生代老年代 的比例

新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ( 该值可以通过参数 –XX:NewRatio 来指定 )

默认的，Eden : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定 )，即： Eden = 8/10 的新生代空间大小，from = to = 1/10 的新生代空间大小。

*Perm代表的是永久代，不算再堆里面，jdk8 以后移除*

-Xss128k：设置每个线程的栈大小。JDK5.0以后每个线程栈大小为1M，之前每个线程栈大小为256K。应当根据应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。需要注意的是：当这个值被设置的较大（例如>2MB）时将会在很大程度上降低系统的性能。
-Xmn2g：设置年轻代大小为2G。在整个堆内存大小确定的情况下，增大年轻代将会减小年老代，反之亦然。此值关系到JVM垃圾回收，对系统性能影响较大，官方推荐配置为整个堆大小的3/8。
-XX:NewSize=1024m：设置年轻代初始值为1024M。
-XX:MaxNewSize=1024m：设置年轻代最大值为1024M。
-XX:PermSize=256m：设置持久代初始值为256M。
-XX:MaxPermSize=256m：设置持久代最大值为256M。
-XX:NewRatio=4：设置年轻代（包括1个Eden和2个Survivor区）与年老代的比值。表示年轻代比年老代为1:4。
-XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的比值。表示2个Survivor区（JVM堆内存年轻代中默认有2个大小相等的Survivor区）与1个Eden区的比值为2:4，即1个Survivor区占整个年轻代大小的1/6。
-XX:MaxTenuringThreshold=7：表示一个对象如果在Survivor区（救助空间）移动了7次还没有被垃圾回收就进入年老代。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代，对于需要大量常驻内存的应用，这样做可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象在年轻代存活时间，增加对象在年轻代被垃圾回收的概率，减少Full GC的频率，这样做可以在某种程度上提高服务稳定性。



### 方法区

- -Xss设置每个线程的堆栈大小
- -XX:+UseParallelGC:选择垃圾收集器为并行收集器。此配置仅对年轻代有效。即上述配置下,年轻代使用并发收集,而年老代仍旧使用串行收集。
- -XX:ParallelGCThreads=20:配置并行收集器的线程数,即:同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。



参数解析 https://blog.csdn.net/Pluto372/article/details/122084515

参数说明 https://zhuanlan.zhihu.com/p/92588056



## 三色标记

在并发的可达性分析算法中我们使用三色标记（Tri-color Marking）来标记对象是否被收集器访问过：

- 白色：表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。
- 黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。
- 灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。

​    可达性分析的扫描过程，其实就是一股以灰色为波峰的波纹从黑向白推进的过程，但是在并发的推进过程中会产生“对象消失”的问题，如图：

链接：https://juejin.cn/post/7303414348932382774

https://zhuanlan.zhihu.com/p/621461833

https://www.bilibili.com/video/BV1KU4y1Y7cu/?spm_id_from=333.337.search-card.all.click&vd_source=72424c3da68577f00ea40a9e4f9001a1

https://www.bilibili.com/video/BV1eu4y127EG/?spm_id_from=333.337.search-card.all.click&vd_source=72424c3da68577f00ea40a9e4f9001a1

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0f6395054ae42a0998c33eea98b8b2a~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1095&h=1155&s=442276&e=png&b=fdfdfd)



## GC 名词概念

https://cloud.tencent.com/developer/article/2308202

#### **部分收集(Partial GC)**

##### **新生代收集**

Young GC   Minor GC

Eden、s1、s2的清理，都是发生在新生代

##### **老年代收集**

Major GC ，Old GC

#### **整堆收集**

Full GC，清理整个堆空间，包括年轻代和老年代，理解

## 垃圾回收 

https://cloud.tencent.com/developer/article/2472162

## 回收算法

### 标记-清除算法

**核心思想**：标记-清除算法是最基础的垃圾收集算法，将垃圾回收分为两个阶段：

1. **标记阶段**：遍历所有对象，标记出需要回收的对象
2. **清除阶段**：回收被标记对象所占用的内存空间

**适用场景**：
- 适用于对象存活率低的场景，如老年代的部分回收
- 适用于对内存碎片不敏感的应用

**优点**：
- 实现简单，不需要移动对象
- 对于大量对象需要回收的场景，效率较高

**缺点**：
- 标记和清除过程效率较低，需要遍历所有对象
- 产生大量不连续的内存碎片，可能导致后续大对象分配失败
- 碎片过多会增加垃圾回收的频率

**工作原理**：
标记-清除算法会标记所有死亡的对象，然后清除它们，留下的存活对象和空闲空间会交错分布，形成内存碎片。

![](https://developer.qcloudimg.com/http-save/9862454/eeeb7395bf13a35400741797f3048283.png)

### 复制算法

**核心思想**：复制算法将内存空间划分为两个相等的区域，每次只使用其中一个。垃圾收集时，将当前区域中的存活对象复制到另一个区域，然后清除整个当前区域。

**适用场景**：
- 适用于对象存活率低的场景，如新生代的回收
- 适用于对内存分配效率要求高的应用

**优点**：
- 实现简单，运行高效
- 按顺序分配内存，不需要考虑内存碎片
- 内存分配速度快，只需指针碰撞即可

**缺点**：
- 可用内存缩小为原来的一半，空间利用率低
- 对象存活率高时会频繁进行复制操作，效率下降

**工作原理**：
复制算法通过将存活对象复制到新区域，然后清空原区域，避免了内存碎片问题。在新生代中，通常将内存分为Eden区和两个Survivor区，比例为8:1:1，每次只使用Eden和一个Survivor区，这样空间利用率可达90%。

![](https://developer.qcloudimg.com/http-save/9862454/cefd4fa40aabbeea1ffe46b7a4576141.png)

### 标记-整理算法

**核心思想**：标记-整理算法结合了标记-清除和复制算法的优点，分为三个阶段：

1. **标记阶段**：标记出需要回收的对象
2. **整理阶段**：将所有存活对象压缩到内存的一端，紧凑排列
3. **清除阶段**：清理边界以外的内存空间

**适用场景**：
- 适用于对象存活率高的场景，如老年代的回收
- 适用于对内存碎片敏感的应用

**优点**：
- 解决了标记-清除算法的内存碎片问题
- 空间利用率高，不需要额外的内存空间

**缺点**：
- 需要移动对象，一定程度上降低了效率
- 整理过程中需要暂停用户线程（STW）

**工作原理**：
标记-整理算法通过移动存活对象，使它们紧凑排列，然后清理边界外的内存，既避免了内存碎片，又提高了空间利用率。

![](https://developer.qcloudimg.com/http-save/9862454/9c6691059a9a8fb2e60393aeaa7009e5.png)

### 分代收集算法

**核心思想**：分代收集算法根据对象的生命周期将内存划分为不同区域，对不同区域采用不同的垃圾收集策略。

**适用场景**：
- 几乎所有现代JVM的默认垃圾收集策略
- 适用于大多数Java应用

**优点**：
- 根据对象特点采用不同策略，提高回收效率
- 减少Full GC的频率，提高应用性能
- 针对性强，优化效果明显

**工作原理**：
1. **新生代**：对象存活率低，采用复制算法，分为Eden区和两个Survivor区
2. **老年代**：对象存活率高，采用标记-清除或标记-整理算法
3. **元空间**：存储类信息，采用专门的回收策略

通过分代收集，Minor GC（新生代回收）频率高但速度快，Major GC（老年代回收）频率低但耗时较长，平衡了回收效率和应用性能。



## GC Root

### 回答1

链接：https://www.zhihu.com/question/595485360/answer/3071179499

GC Root（Garbage Collection Root）是指

在Java虚拟机中被直接或间接引用的对象集合，它们被认为是存活对象，不能被垃圾回收器回收。

GC Root包括以下几种类型：

 **1.虚拟机栈中引用的对象**

每次函数调用调用都是一次入栈。在栈中包括局部变量表和操作数栈，局部变量表中的变量可能为引用类型(reference)，他们引用的对象即可作为GC Root。不过随着函数调用结束出栈，这些引用便会消失。

 **2.方法区中类静态属性引用的对象**

简单的说就是我们在类中使用的static声明的引用类型字段

 **3.方法区中常量引用的对象**

简单的说就是我们在类中使用final声明的引用类型字段

 **4.Native方法中引用的对象**

就是程序中native本地方法引用的对象

 **5.活动线程中的对象**

 **6.当前类加载器加载的类的对象**

GC Root的作用是为垃圾回收器提供一个初始的扫描位置，以便确定哪些对象是可达的，哪些对象是不可达的。垃圾回收器会从GC Root开始扫描，并标记所有可达对象，最终将不可达对象回收掉。

### 回答2

#### GC Root 的特点

当前时刻存活的对象

#### GC Root 在哪里

所有Java线程当前活跃的栈帧里指向GC堆里的对象的引用；换句话说，当前所有正在被调用的方法的引用类型的参数/局部变量/临时值。
VM的一些静态数据结构里指向GC堆里的对象的引用，例如说HotSpot VM里的Universe里有很多这样的引用。



## 回收器

### 垃圾回收器概述

垃圾回收器是JVM中负责执行垃圾回收的组件，不同的垃圾回收器采用不同的算法和策略，适用于不同的应用场景。根据回收线程的数量和执行方式，垃圾回收器可以分为以下几类：

- **串行收集器**：单线程执行垃圾回收，适用于单核CPU环境
- **并行收集器**：多线程执行垃圾回收，提高回收效率
- **并发收集器**：与用户线程并发执行垃圾回收，减少STW时间
- **增量收集器**：将垃圾回收分解为多个小步骤，逐步执行

### Serial收集器

**背景**：Serial收集器是最古老、最基本的垃圾收集器，也是JVM客户端模式下的默认收集器。

**特点**：
- 单线程执行垃圾回收，只使用一个CPU核心
- 新生代采用复制算法，老年代采用标记-整理算法
- 执行过程中会暂停所有用户线程（STW）

**适用场景**：
- 适用于单核CPU环境
- 适用于内存较小的客户端应用
- 适用于对响应时间要求不高的场景

**优点**：
- 实现简单，代码量小
- 单线程执行，没有线程切换开销
- 在单核CPU环境下效率较高

**缺点**：
- 垃圾回收时会暂停所有用户线程，导致应用卡顿
- 在多核CPU环境下，无法充分利用硬件资源
- 不适用于大型服务器应用

### Serial Old收集器

**背景**：Serial Old是Serial收集器的老年代版本，主要用于与其他收集器配合使用。

**特点**：
- 单线程执行老年代垃圾回收
- 采用标记-整理算法
- 执行过程中会暂停所有用户线程

**适用场景**：
- 作为CMS收集器的备选方案，当CMS收集失败时使用
- 在JDK 5之前与Parallel Scavenge收集器配合使用
- 适用于小型应用或客户端环境

### ParNew收集器

**背景**：ParNew是Serial收集器的并行版本，主要用于与CMS收集器配合使用。

**特点**：
- 多线程执行新生代垃圾回收
- 新生代采用复制算法
- 执行过程中会暂停所有用户线程

**适用场景**：
- 适用于多核CPU环境
- 与CMS收集器配合使用，作为新生代收集器
- 适用于对响应时间有一定要求的服务器应用

**优点**：
- 多线程执行，充分利用多核CPU资源
- 与CMS收集器兼容性好
- 新生代回收速度快

**缺点**：
- 垃圾回收时会暂停所有用户线程
- 线程数量过多时，线程切换开销会影响性能

### Parallel Scavenge收集器

**背景**：Parallel Scavenge是一款专注于吞吐量的并行收集器，也称为"吞吐量优先收集器"。

**特点**：
- 多线程执行垃圾回收
- 新生代采用复制算法，老年代采用标记-整理算法
- 执行过程中会暂停所有用户线程
- 支持自适应调节策略，可以根据系统运行情况自动调整内存分配和回收策略

**适用场景**：
- 适用于多核CPU环境
- 适用于对吞吐量要求较高的应用，如科学计算、批处理任务
- 适用于后台服务，对响应时间要求不高的场景

**优点**：
- 高吞吐量，适合计算密集型应用
- 自适应调节能力强，减少人工调优成本
- 多线程执行，充分利用硬件资源

**缺点**：
- 垃圾回收时会暂停所有用户线程
- 对响应时间敏感的应用不友好

### Parallel Old收集器

**背景**：Parallel Old是Parallel Scavenge收集器的老年代版本，在JDK 6中引入。

**特点**：
- 多线程执行老年代垃圾回收
- 采用标记-整理算法
- 执行过程中会暂停所有用户线程

**适用场景**：
- 与Parallel Scavenge收集器配合使用，组成"Parallel Scavenge + Parallel Old"的收集器组合
- 适用于对吞吐量要求较高的应用

### CMS收集器

**背景**：CMS（Concurrent Mark Sweep）收集器是一款以低延迟为目标的并发收集器，在JDK 5中引入。

**特点**：
- 并发执行垃圾回收，减少STW时间
- 老年代采用标记-清除算法
- 执行过程分为四个阶段：初始标记、并发标记、重新标记、并发清除

**适用场景**：
- 适用于对响应时间要求较高的应用，如Web服务器、电子商务系统
- 适用于多核CPU环境
- 适用于内存较大的服务器应用

**优点**：
- 并发执行，减少STW时间，提高应用响应速度
- 适用于对延迟敏感的应用

**缺点**：
- 采用标记-清除算法，会产生内存碎片
- 对CPU资源敏感，并发执行时会占用部分CPU资源
- 无法处理浮动垃圾，可能导致并发失败
- 老年代空间不足时会触发Full GC，导致长时间STW

### G1收集器

**背景**：G1（Garbage First）收集器是Oracle在JDK 7中引入的一款面向服务器端应用的垃圾收集器，在JDK 9中成为默认收集器。

**特点**：
- 采用分区（Region）思想，将堆内存划分为多个大小相等的区域
- 局部采用复制算法，整体采用标记-整理算法，避免内存碎片
- 支持可预测的停顿时间，用户可以设置最大GC停顿时间
- 执行过程包括：年轻代回收、混合回收、Full GC

**适用场景**：
- 适用于大内存、多核CPU环境
- 适用于对响应时间有较高要求的服务器应用
- 适用于需要控制GC停顿时间的场景
- 适用于替代CMS收集器的场景

**优点**：
- 支持可预测的停顿时间，满足实时性要求
- 避免内存碎片，提高内存利用率
- 并发执行，减少STW时间
- 适用于大内存环境

**缺点**：
- 实现复杂，代码量较大
- 在小内存环境下，性能不如其他收集器
- 对CPU资源要求较高

### ZGC收集器

**背景**：ZGC（Z Garbage Collector）是Oracle在JDK 11中引入的一款低延迟垃圾收集器，专为大内存、低延迟场景设计。

**特点**：
- 采用彩色指针技术和读屏障
- 并发执行所有垃圾回收阶段，几乎无STW
- 支持TB级内存
- 停顿时间控制在毫秒级别

**适用场景**：
- 适用于超大内存环境（TB级）
- 适用于对延迟要求极高的应用，如金融交易系统、实时数据分析
- 适用于多核CPU环境

**优点**：
- 极低的GC停顿时间，几乎不影响应用运行
- 支持超大内存
- 并发执行，对应用影响小

**缺点**：
- 对CPU资源要求较高
- 实现复杂，维护成本高
- 在小内存环境下，性能不如其他收集器

### Shenandoah收集器

**背景**：Shenandoah是Red Hat开发的一款低延迟垃圾收集器，在JDK 12中引入。

**特点**：
- 采用并发标记-整理算法
- 支持并发执行所有垃圾回收阶段
- 停顿时间与堆大小无关

**适用场景**：
- 适用于大内存环境
- 适用于对延迟要求较高的应用
- 适用于多核CPU环境

**优点**：
- 低停顿时间，适合实时应用
- 支持大内存
- 与应用并发执行，影响小

**缺点**：
- 对CPU资源要求较高
- 实现复杂
- 在某些场景下，吞吐量可能不如其他收集器

### 垃圾回收器比对分析

| 收集器 | 类型 | 新生代算法 | 老年代算法 | 目标 | 适用场景 |
|--------|------|-----------|-----------|------|----------|
| Serial | 串行 | 复制 | 标记-整理 | 简单高效 | 客户端应用 |
| ParNew | 并行 | 复制 | - | 低延迟 | 与CMS配合使用 |
| Parallel Scavenge | 并行 | 复制 | 标记-整理 | 高吞吐量 | 计算密集型应用 |
| CMS | 并发 | - | 标记-清除 | 低延迟 | Web服务器 |
| G1 | 并发 | 复制 | 标记-整理 | 可预测停顿 | 大内存服务器 |
| ZGC | 并发 | - | 标记-整理 | 极低延迟 | 超大内存环境 |
| Shenandoah | 并发 | - | 标记-整理 | 低延迟 | 大内存环境 |

### 垃圾回收器选择建议

1. **客户端应用**：优先选择Serial收集器，简单高效

2. **对吞吐量要求高的应用**：优先选择Parallel Scavenge + Parallel Old组合

3. **对响应时间要求高的应用**：优先选择G1收集器

4. **超大内存、极低延迟要求**：优先选择ZGC或Shenandoah收集器

5. **传统服务器应用**：可以选择CMS收集器，但建议迁移到G1

6. **多核CPU环境**：避免使用串行收集器，充分利用并行或并发收集器

7. **小内存环境**：选择Serial或ParNew收集器

8. **大内存环境**：选择G1、ZGC或Shenandoah收集器

## GC 相关

### 执行过程

**GC回收流程如下：**

**1、** 对于整个的GC流程里面，那么最需要处理的就是新生代和老年代的内存清理操作，而元空间（永久代）都不在GC范围内

**2、** 当现在有一个新的对象产生，那么对象一定需要内存空间，平均每个栈内存存4k，每个堆内存存8k，那么对象一定需要进行堆空间的申请

**3、** 首先会判断Eden区是否有内存空间，如果此时有内存空间，则直接将新对象保存在伊甸园区。

**4、** 但是如果此时在伊甸园区内存不足，那么会自动执行一个Minor GC 操作，将伊甸园区的无用内存空间进行清理，Minor GC的清理范围只在Eden园区，清理之后会继续判断Eden园区的内存空间是否充足？如果内存空间充足，则将新对象直接在Eden园区进行空间分配。

**5、** 如果执行Minor GC 之后发现伊甸园区的内存空间依然不足，那么这个时候会执行存活区的判断，如果存活区有剩余空间，则将Eden园区部分活跃对象保存在存活区，那么随后继续判断Eden园区的内存空间是否充足，如果充足怎则将新对象直接在Eden园区进行空间分配。

**6、** 此时如果存活区没有内存空间，则继续判断老年区。则将部分存活对象保存在老年代，而后存活区将有空余空间。

**7、** 如果这个时候老年代也满了，那么这个时候将产生Major GC（Full GC）,那么这个时候将进行老年代的清理

**8、** 如果老年代执行Full GC之后，无法进行对象的保存，则会产生OOM异常,OutOfMemoryError异常

### 分代执行过程

分为新生代和老年代，新生代默认占总空间的 1/3，老年代默认占 2/3。

新生代使用复制算法，有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1。

当新生代中的 Eden 区内存不足时，就会触发 Minor GC，过程如下：

**1、** 在 Eden 区执行了第一次 GC 之后，存活的对象会被移动到其中一个 Survivor 分区；

**2、** Eden 区再次 GC，这时会采用复制算法，将 Eden 和 from 区一起清理，存活的对象会被复制到 to 区；

**3、** 移动一次，对象年龄加 1，对象年龄大于一定阀值会直接移动到老年代

**4、** Survivor 区相同年龄所有对象大小的总和 (Survivor 区内存大小 * 这个目标使用率)时，大于或等于该年龄的对象直接进入老年代。其中这个使用率通过 -XX:TargetSurvivorRatio 指定，默认为 50%

**5、** Survivor 区内存不足会发生担保分配

**6、** 超过指定大小的对象可以直接进入老年代

Major GC，指的是老年代的垃圾清理，但并未找到明确说明何时在进行Major GC

FullGC，整个堆的垃圾收集，触发条件：

**1、** 每次晋升到老年代的对象平均大小>老年代剩余空间

**2、** MinorGC后存活的对象超过了老年代剩余空间

**3、** 元空间不足

**4、** System.gc() 可能会引起

**5、** CMS GC异常，promotion failed:MinorGC时，survivor空间放不下，对象只能放入老年代，而老年代也放不下造成；concurrent mode failure:GC时，同时有对象要放入老年代，而老年代空间不足造成

**6、** 堆内存分配很大的对象

### 触发条件 

https://zhuanlan.zhihu.com/p/618722706





常用优化



不同类型差别



### GC 日志

```
[346.934s][info ][gc,start    ] GC(271) Pause Young (Normal) (G1 Evacuation Pause)
[346.934s][info ][gc,task     ] GC(271) Using 8 workers of 8 for evacuation
[346.937s][info ][gc,phases   ] GC(271)   Pre Evacuate Collection Set: 0.1ms
[346.937s][info ][gc,phases   ] GC(271)   Merge Heap Roots: 0.1ms
[346.937s][info ][gc,phases   ] GC(271)   Evacuate Collection Set: 1.8ms
[346.937s][info ][gc,phases   ] GC(271)   Post Evacuate Collection Set: 0.6ms
[346.937s][info ][gc,phases   ] GC(271)   Other: 0.2ms
[346.937s][info ][gc,heap     ] GC(271) Eden regions: 426->0(426)
[346.937s][info ][gc,heap     ] GC(271) Survivor regions: 4->4(54)
[346.937s][info ][gc,heap     ] GC(271) Old regions: 170->170
[346.937s][info ][gc,heap     ] GC(271) Archive regions: 2->2
[346.937s][info ][gc,heap     ] GC(271) Humongous regions: 0->0
[346.937s][info ][gc,metaspace] GC(271) Metaspace: 59579K(60096K)->59579K(60096K) NonClass: 52231K(52480K)->52231K(52480K) Class: 7348K(7616K)->7348K(7616K)
[346.937s][info ][gc          ] GC(271) Pause Young (Normal) (G1 Evacuation Pause) 1200M->347M(1434M) 2.672ms
[346.937s][info ][gc,cpu      ] GC(271) User=0.01s Sys=0.00s Real=0.00s
2023-08-01T09:06:56.477+08:00  INFO 39312 --- [io-8000-exec-51] c.b.s.b.p.s.mock.UserServiceMockImpl     : UserServiceMockImpl mockOne cost = 14

```



user代表进程在用户态消耗的CPU时间，

sys代表代表进程在内核态消耗的CPU时间，

real代表程序从开始到结束所用的时钟时间。这个时间包括其他进程使用的时间片和进程阻塞的时间（比如等待 I/O 完成）。





## 内存分配

大对象直接进老年代 

https://blog.csdn.net/zhou920786312/article/details/123536294



## 初始过程 

**比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，他们的执行顺序**

先静态、先父后子。

先静态：父静态 > 子静态

优先级：父类 > 子类 静态代码块 > 非静态代码块 > 构造函数



## SafePoint

https://zhuanlan.zhihu.com/p/286110609

### 安全点 

STW并不会只发生在内存回收的时候。现在程序员这么卷，碰到几次safepoint的问题几率也是比较大的。

当发生GC时，用户线程必须全部停下来，才可以进行垃圾回收，这个状态我们可以认为JVM是安全的（safe），整个堆的状态是稳定的。

如果在GC前，有线程迟迟进入不了safepoint，那么整个JVM都在等待这个阻塞的线程，造成了整体GC的时间变长。





- 现在可达性分析算法耗时最长的查找引用链的过程已经可以做到与用户线程一起并发，但根节点枚举始终还是必须在一个能保障一致性的快照中才得以进行

- 即使是号称停顿时间可控，或者（几乎）不会发生停顿的CMS、G1、 ZGC等收集器，枚举根节点时也是必须要停顿的



- 用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集，而是强制要求必须执行到达安全点后才能够暂停。



### 选择标准

安全点位置的选择标准是：是否能让程序长时间执行；所以会在方法调用、循环跳转、异常跳转等处才会产生安全点

HotSpot会在所有方法的临返回之前，以及所有非counted loop的循环的回跳之前放置安全点。

“长时间执行”的最明显特征就是指令序列的复用，例如方法调用、循环跳转、异常跳转 等都属于指令序列复用，所以只有具有这些功能的指令才会产生安全点。





### 中断停顿

- 抢先式中断

“抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就”

“恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。

- 主动式中断

而主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。”



### 安全域

“使用Safepoint似乎已经完美地解决了如何进入GC的问题，但实际情况却并不一定。Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？所谓的程序不执行就是没有分配CPU时间，典型的例子就是线程处于Sleep状态或者Blocked状态，这时候线程无法响应JVM的中断请求，“走”到安全的地方去中断挂起，JVM也显然不太可能等待线程重新被分配CPU时间。对于这种情况，就需要安全区域（Safe Region）来解决。”





## MAT

参考链接 https://c.m.163.com/news/a/HL40JTCI0552ZNXL.html

入门 https://juejin.cn/post/6908665391136899079

进阶 https://juejin.cn/post/6911624328472133646

官网 https://help.eclipse.org/latest/index.jsp?topic=/org.eclipse.mat.ui.help/welcome.html





### 概况

Leak Suspects 》 System Overview

- Heap Dump Overview 
- System Properties
- Thread Overview
- Top Consumers
  - Biggest Objects (Overview)
  - Biggest Objects
  - Biggest Top-Level Dominator Classes (Overview)
  - Biggest Top-Level Dominator Classes
  - Biggest Top-Level Dominator Class Loaders (Overview)
  - Biggest Top-Level Dominator Class Loaders
  - Biggest Top-Level Dominator Packages
- Class Histogram



## 架构



## Bilibili 



## 参考链接 

JVM 知识汇总 https://juejin.cn/post/7303386068606812199

GC 解析 https://juejin.cn/post/7303414348932382774



jvm参数配置 https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html

内容解析 https://www.zhihu.com/column/c_1268282634804400128

加载过程解析 https://my.oschina.net/u/4090830/blog/10141305



【itv】https://github.com/whx123/JavaHome/blob/master/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E7%BB%93%E5%8F%B7/JVM%20%E7%AF%87/JVM%E9%9D%A2%E8%AF%95%E9%A2%98.md

【itv2】

https://github.com/rbmonster/learning-note/blob/master/src/main/java/com/toc/JVM.md



https://blog.csdn.net/zouliping123456/article/details/124522802

https://blog.csdn.net/weixin_59262008/article/details/125676787

https://zhuanlan.zhihu.com/p/375202547

https://www.cnblogs.com/hanease/p/15869727.html