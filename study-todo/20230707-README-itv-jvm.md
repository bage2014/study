# JVM深度解析与实践指南

## 1. 简介

本指南详细介绍Java虚拟机（JVM）的核心概念、工作原理、垃圾回收机制以及性能调优策略，旨在帮助开发者深入理解JVM内部机制，从而编写更高效的Java应用并进行有效的性能优化。

主要聚焦于HotSpot JVM，这是目前应用最广泛的JVM实现。

## 2. JVM背景与历史

### 2.1 发展历程

JVM（Java Virtual Machine）的历史可以追溯到1990年代初，当时Sun Microsystems公司的James Gosling领导的团队开始开发一种名为"Green Project"的编程语言，旨在为消费电子产品创建一种可移植的编程解决方案。

1. **1991年**：Green Project启动，开发了一种名为Oak的编程语言，这是Java的前身。

2. **1995年**：Sun正式发布Java 1.0，同时推出了JVM规范。JVM的设计理念是"一次编写，到处运行"（Write Once, Run Anywhere），通过将Java代码编译为字节码，然后由不同平台上的JVM解释执行，实现了跨平台兼容性。

3. **1997年**：Java 1.1发布，引入了JIT（Just-In-Time）编译器，显著提高了Java程序的执行效率。

4. **2000年**：Java 2平台发布，包括J2SE、J2EE和J2ME三个版本，JVM也得到了相应的增强。

5. **2006年**：Sun宣布Java技术开源，成立了OpenJDK项目，JVM的开发开始由社区共同参与。

6. **2009年**：Oracle收购Sun Microsystems，成为Java和JVM的新所有者。

7. **2014年**：Java 8发布，引入了Lambda表达式、Stream API等重要特性，同时JVM在性能和垃圾回收方面也有了显著改进。

8. **2018年**：Java 11发布，这是第一个长期支持（LTS）版本，同时引入了ZGC等新的垃圾回收器。

9. **2021年**：Java 17发布，这是最新的LTS版本，进一步增强了JVM的性能和功能。

### 2.2 技术演进

JVM的技术演进主要体现在以下几个方面：

1. **执行引擎优化**：从最初的纯解释执行，到引入JIT编译器，再到分层编译（Tiered Compilation），不断提高Java程序的执行效率。

2. **内存管理改进**：从早期的简单内存模型，到分代收集，再到G1、ZGC等先进的垃圾回收器，内存管理的效率和可靠性不断提升。

3. **并发处理增强**：引入了更高效的并发数据结构和同步机制，支持更大规模的并发应用。

4. **安全性提升**：不断加强JVM的安全机制，防止恶意代码的执行。

5. **工具链完善**：提供了丰富的监控、诊断和调优工具，如JConsole、VisualVM、JMC等，帮助开发者更好地理解和优化JVM的运行状态。

### 2.3 重要的JVM实现

除了Oracle的HotSpot JVM外，还有其他一些重要的JVM实现：

| JVM实现 | 开发方 | 特点 | 适用场景 |
|--------|-------|------|----------|
| HotSpot | Oracle | 高性能、功能丰富，主流JVM实现 | 大多数Java应用 |
| OpenJ9 | Eclipse基金会 | 低内存占用、快速启动 | 云原生应用、微服务 |
| GraalVM | Oracle | 支持多语言、AOT编译 | 多语言混合开发、高性能计算 |
| Azul Zing | Azul Systems | 低延迟、可预测性强 | 金融交易系统、实时应用 |
| BEA JRockit | Oracle (已整合到HotSpot) | 高性能、低延迟 | 已不再单独使用 |

## 3. JVM架构

### 3.1 整体架构

JVM架构由以下几个主要部分组成：

![](https://images0.cnblogs.com/i/288799/201405/281726404166686.jpg)

### 3.2 内存结构

JVM内存结构分为以下几个区域：

#### 3.2.1 程序计数器

程序计数器（Program Counter Register）是一块较小的内存空间，用于保存程序当前执行的指令地址。

- **功能**：当CPU需要执行指令时，从程序计数器中获取当前指令的地址，执行完毕后自动更新为下一条指令的地址。
- **特点**：
  - 线程私有，每个线程都有自己独立的程序计数器
  - 如果线程执行的是非native方法，保存的是当前指令的地址
  - 如果线程执行的是native方法，值为undefined
  - 不会发生内存溢出（OutOfMemoryError）

#### 3.2.2 Java虚拟机栈

Java虚拟机栈（Java Virtual Machine Stack）是Java方法执行的内存模型，每个方法执行时都会创建一个栈帧。

- **栈帧组成**：
  - 局部变量表：存储方法参数和局部变量
  - 操作数栈：用于方法执行过程中的计算
  - 动态链接：指向运行时常量池的引用
  - 方法返回地址：方法执行完毕后返回的地址

- **特点**：
  - 线程私有
  - 栈深度有限，过深会导致StackOverflowError
  - 内存不足时会抛出OutOfMemoryError

#### 3.2.3 本地方法栈

本地方法栈（Native Method Stack）与Java虚拟机栈类似，但是为执行本地（Native）方法服务。

- **特点**：
  - 线程私有
  - 在HotSpot JVM中，本地方法栈与Java虚拟机栈合二为一
  - 同样可能抛出StackOverflowError和OutOfMemoryError

#### 3.2.4 堆

堆（Heap）是JVM中最大的内存区域，用于存储对象实例和数组。

- **特点**：
  - 线程共享
  - 垃圾收集器的主要工作区域
  - 内存不足时会抛出OutOfMemoryError

- **堆空间划分**：
  - 新生代（Young Generation）：对象新建区域，分为Eden区和两个Survivor区（From和To）
  - 老年代（Old Generation）：存放存活时间较长的对象
  - 元空间（Metaspace）：JDK 8+中替代永久代，存储类元数据

#### 3.2.5 方法区

方法区（Method Area）用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

- **特点**：
  - 线程共享
  - 在JDK 7及之前称为永久代（Permanent Generation）
  - 在JDK 8及之后被元空间（Metaspace）替代
  - 内存不足时会抛出OutOfMemoryError

### 3.3 执行引擎

执行引擎负责执行字节码，主要包括以下组件：

- **解释器**：逐行解释执行字节码，启动速度快
- **JIT编译器**：将热点代码编译为本地机器码，提高执行效率
- **垃圾回收器**：自动回收不再使用的内存



## 4. 字节码文件

### 4.1 文件结构

Java字节码文件（.class文件）是一种二进制格式文件，包含了以下主要结构：

- **魔数**：0xCAFEBABE，用于识别.class文件
- **版本号**：包含主版本号和次版本号
- **常量池**：存储字面量和符号引用
- **访问标志**：标识类的访问权限和属性
- **类索引、父类索引和接口索引**：确定类的继承关系
- **字段表集合**：描述类的字段信息
- **方法表集合**：描述类的方法信息
- **属性表集合**：存储类的附加信息

![](https://pdai.tech/images/jvm/java-jvm-class-2.png)

### 4.2 反编译工具

使用`javap`命令可以反编译.class文件，查看其内部结构：

```bash
# 查看详细信息，包括常量池、方法表等
javap -verbose -p Main.class

# 编译Java文件
javac HelloTest.java
```



## 5. 类加载过程

### 5.1 概述

Java程序的运行过程可以分为三个主要阶段：编译 → 类加载 → 执行。

类加载是JVM将.class文件加载到内存并转换为运行时数据结构的过程，是Java程序运行的基础。

![](https://oss.javaguide.cn/github/javaguide/java/basis/jvm-rough-structure-model.png)

### 5.2 类加载的主要过程

类加载过程由JVM负责，主要分为三个阶段：

#### 5.2.1 加载（Loading）

- **功能**：将编译完成的.class二进制文件加载到内存，生成对应的Class对象。
- **过程**：
  1. 通过类的全限定名获取.class文件的二进制字节流
  2. 将字节流所代表的静态存储结构转换为方法区的运行时数据结构
  3. 在内存中生成一个代表该类的Class对象，作为方法区中该类数据的访问入口

- **类加载器**：
  - Bootstrap ClassLoader：加载Java核心类库
  - Extension ClassLoader：加载扩展类库
  - Application ClassLoader：加载应用程序类
  - 自定义类加载器：根据需要自定义加载逻辑

#### 5.2.2 连接（Linking）

连接阶段是将加载到内存的类的二进制数据合并到JVM的运行时环境中，分为三个步骤：

##### 5.2.2.1 验证（Verification）

- **功能**：确保加载的类符合JVM规范，保证安全性。
- **验证内容**：
  - 文件格式验证：确保.class文件格式正确
  - 元数据验证：验证类的元数据信息
  - 字节码验证：验证字节码指令的合法性
  - 符号引用验证：验证符号引用的有效性

##### 5.2.2.2 准备（Preparation）

- **功能**：为类的静态变量分配内存，并设置默认初始值。
- **特点**：
  - 只为静态变量分配内存，不包括实例变量
  - 初始值为JVM默认值，而非程序中定义的初始值
  - 例如：int类型默认值为0，boolean类型默认值为false，引用类型默认值为null

##### 5.2.2.3 解析（Resolution）

- **功能**：将类中的符号引用转换为直接引用。
- **概念**：
  - 符号引用：以字符串形式表示的引用，如方法名、字段名
  - 直接引用：指向目标的指针、偏移量或句柄
- **解析对象**：类、接口、字段、方法等

#### 5.2.3 初始化（Initialization）

- **功能**：为类的静态变量赋予程序中定义的初始值，并执行静态代码块。
- **触发条件**：
  - 创建类的实例
  - 调用类的静态方法
  - 访问类的静态字段
  - 反射调用
  - 初始化子类时，父类会先初始化
  - 执行main方法的类

- **执行顺序**：
  1. 父类静态变量和静态代码块
  2. 子类静态变量和静态代码块
  3. 父类实例变量和实例代码块
  4. 父类构造方法
  5. 子类实例变量和实例代码块
  6. 子类构造方法



## 6. 对象初始化

### 6.1 对象创建的过程

Java对象的创建过程主要包括以下步骤：

#### 6.1.1 类加载检查

当JVM遇到一条`new`指令时，首先会检查：

- 指令参数是否能在常量池中定位到一个类的符号引用
- 该符号引用代表的类是否已被加载、解析和初始化

如果类尚未加载，则需要先执行类加载过程。

#### 6.1.2 分配内存

类加载检查通过后，JVM为新生对象分配内存：

- **内存大小**：对象所需内存大小在类加载完成后已确定
- **分配方式**：
  - **指针碰撞**：如果堆内存规整，通过移动指针分配内存
  - **空闲列表**：如果堆内存不规整，通过空闲列表分配内存

- **线程安全**：
  - 采用CAS（Compare-And-Swap）机制保证线程安全
  - 或使用TLAB（Thread Local Allocation Buffer）为每个线程预分配内存

#### 6.1.3 初始化零值

为对象的实例变量设置默认零值，确保对象在不赋初值的情况下也能使用。

#### 6.1.4 设置对象头

设置对象头信息，包括：

- 对象的运行时数据（哈希码、GC分代年龄等）
- 指向对象所属类元数据的指针
- 如有必要，设置偏向锁标志

#### 6.1.5 执行＜init＞方法

执行构造方法，为对象的实例变量赋予正确的初始值，完成对象的初始化。

### 6.2 对象初始化的顺序

对象初始化时，各部分的执行顺序为：

1. 父类静态变量和静态代码块
2. 子类静态变量和静态代码块
3. 父类实例变量和实例代码块
4. 父类构造方法
5. 子类实例变量和实例代码块
6. 子类构造方法 



## 7. 内存分配方式

### 7.1 指针碰撞（Bump the Pointer）

**适用场景**：当Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边。

**分配过程**：
- 中间有一个指针作为分界点的指示器
- 分配内存时，只需将指针向空闲空间方向挪动一段与对象大小相等的距离

**优点**：
- 分配速度快，只需移动指针
- 实现简单

### 7.2 空闲列表（Free List）

**适用场景**：当Java堆中的内存不规整，已使用的内存和空闲的内存相互交错。

**分配过程**：
- 虚拟机维护一个列表，记录哪些内存块是可用的
- 分配时，从列表中找到一块足够大的空间划分给对象实例
- 更新列表上的记录，标记已分配的内存

**优点**：
- 可以处理内存碎片问题
- 适用于内存使用频繁、对象大小不一的场景

### 7.3 线程安全的内存分配

由于堆是线程共享的，内存分配过程中需要考虑线程安全问题。JVM采用以下两种方式保证线程安全：

#### 7.3.1 CAS机制

- 使用CAS（Compare-And-Swap）操作配合失败重试机制，保证内存分配的原子性
- 适用于内存分配频繁的场景

#### 7.3.2 TLAB（Thread Local Allocation Buffer）

- 为每个线程预分配一块独立的内存区域
- 线程在自己的TLAB中分配内存，不需要加锁
- 只有当TLAB用完需要重新分配时，才需要进行CAS操作
- 提高了内存分配的效率

### 7.4 内存分配策略

1. **对象优先在Eden区分配**：大多数对象在Eden区创建
2. **大对象直接进入老年代**：超过一定大小的对象直接分配到老年代
3. **长期存活的对象进入老年代**：对象年龄达到阈值后进入老年代
4. **动态对象年龄判断**：如果Survivor区中相同年龄的对象总和超过一半，年龄大于等于该年龄的对象直接进入老年代
5. **空间分配担保**：Minor GC前，检查老年代剩余空间是否足够容纳新生代所有对象，如果不足，可能会提前触发Full GC 



## 8. JVM参数解析

### 8.1 参数查看方法

**1、** 使用`jps -v`查看JVM进程的参数
**2、** 使用`-XX:+PrintFlagsFinal`查看JVM所有参数的值
**3、** 使用`jinfo`实时查看和调整虚拟机各项参数

### 8.2 堆相关参数

| 参数 | 描述 | 默认值 |
|------|------|--------|
| `-Xms` | 初始堆大小 | 物理内存的1/64 |
| `-Xmx` | 最大堆大小 | 物理内存的1/4 |
| `-XX:MinHeapFreeRatio` | 最小堆空闲比例 | 40% |
| `-XX:MaxHeapFreeRatio` | 最大堆空闲比例 | 70% |
| `-XX:NewRatio` | 新生代与老年代的比例 | 2 (1:2) |
| `-XX:SurvivorRatio` | Eden区与Survivor区的比例 | 8 (8:1:1) |
| `-Xmn` | 年轻代大小 | 堆大小的1/4左右 |
| `-XX:NewSize` | 年轻代初始值 | - |
| `-XX:MaxNewSize` | 年轻代最大值 | - |
| `-XX:MaxTenuringThreshold` | 对象进入老年代的年龄阈值 | 7 |

### 8.3 方法区/元空间参数

| 参数 | 描述 | 默认值 |
|------|------|--------|
| `-XX:MetaspaceSize` | 元空间初始大小 | 21MB |
| `-XX:MaxMetaspaceSize` | 元空间最大值 | 无限制 |
| `-XX:MinMetaspaceFreeRatio` | 元空间最小空闲比例 | 40% |
| `-XX:MaxMetaspaceFreeRatio` | 元空间最大空闲比例 | 70% |

### 8.4 栈相关参数

| 参数 | 描述 | 默认值 |
|------|------|--------|
| `-Xss` | 每个线程的栈大小 | JDK 5.0+为1M，之前为256K |

### 8.5 垃圾收集器参数

| 参数 | 描述 | 适用收集器 |
|------|------|------------|
| `-XX:+UseSerialGC` | 使用串行收集器 | Serial |
| `-XX:+UseParNewGC` | 使用ParNew收集器 | ParNew |
| `-XX:+UseParallelGC` | 使用Parallel Scavenge收集器 | Parallel Scavenge |
| `-XX:+UseParallelOldGC` | 使用Parallel Old收集器 | Parallel Old |
| `-XX:+UseConcMarkSweepGC` | 使用CMS收集器 | CMS |
| `-XX:+UseG1GC` | 使用G1收集器 | G1 |
| `-XX:+UseZGC` | 使用ZGC收集器 | ZGC |
| `-XX:+UseShenandoahGC` | 使用Shenandoah收集器 | Shenandoah |

### 8.6 GC调优参数

| 参数 | 描述 | 默认值 |
|------|------|--------|
| `-XX:ParallelGCThreads` | 并行收集器的线程数 | CPU核心数 |
| `-XX:MaxGCPauseMillis` | 最大GC停顿时间 | - |
| `-XX:GCTimeRatio` | GC时间占总时间的比例 | 99 |
| `-XX:CMSInitiatingOccupancyFraction` | CMS收集器老年代触发阈值 | 92% |
| `-XX:+UseCMSInitiatingOccupancyOnly` | 只在达到阈值时触发CMS | false |
| `-XX:InitiatingHeapOccupancyPercent` | G1收集器触发阈值 | 45% |

### 8.7 日志相关参数

| 参数 | 描述 | 适用版本 |
|------|------|----------|
| `-XX:+PrintGCDetails` | 打印详细GC日志 | JDK 8及以下 |
| `-XX:+PrintGCDateStamps` | 打印GC时间戳 | JDK 8及以下 |
| `-Xloggc:gc.log` | GC日志输出到文件 | JDK 8及以下 |
| `-Xlog:gc*` | 开启GC日志 | JDK 9+ |
| `-Xlog:gc*:file=gc.log` | GC日志输出到文件 | JDK 9+ |



## 9. 三色标记

### 9.1 基本概念

三色标记（Tri-color Marking）是一种用于并发可达性分析的算法，通过三种颜色标记对象的状态：

| 颜色 | 含义 |
|------|------|
| **白色** | 对象尚未被垃圾收集器访问过。分析开始时所有对象都是白色，分析结束后仍为白色的对象表示不可达，将被回收。 |
| **黑色** | 对象已经被垃圾收集器访问过，且其所有引用都已扫描完毕。黑色对象是安全存活的，不需要重新扫描。 |
| **灰色** | 对象已经被垃圾收集器访问过，但至少有一个引用尚未被扫描。灰色对象是分析过程中的中间状态。 |

### 9.2 工作原理

可达性分析的扫描过程可以看作是一股以灰色为波峰的波纹从黑向白推进的过程：

1. **初始状态**：所有对象都是白色
2. **标记根对象**：将GC Root标记为灰色
3. **扫描过程**：
   - 取出一个灰色对象，标记为黑色
   - 扫描其所有引用，将引用的对象标记为灰色
   - 重复此过程，直到没有灰色对象
4. **结束状态**：所有白色对象都是不可达的，将被回收

### 9.3 并发标记的问题

在并发标记过程中，由于用户线程仍在运行，可能会导致"对象消失"的问题：

#### 9.3.1 对象消失的场景

1. **场景一**：黑色对象指向新的白色对象
   - 黑色对象A新建了对白色对象B的引用
   - 由于A已经是黑色，不会被重新扫描，导致B无法被标记

2. **场景二**：灰色对象断开对白色对象的引用
   - 灰色对象C断开了对白色对象D的引用
   - 同时，黑色对象E新建了对D的引用
   - 由于C仍在扫描中，可能导致D被错误回收

### 9.4 解决方案

为了解决并发标记中的对象消失问题，JVM采用了以下两种方案：

#### 9.4.1 增量更新（Incremental Update）

- **原理**：当黑色对象新建对白色对象的引用时，将黑色对象重新标记为灰色
- **适用**：CMS收集器采用此方案

#### 9.4.2 原始快照（Snapshot At The Beginning, SATB）

- **原理**：在并发标记开始时创建一个快照，记录所有可达对象
- **适用**：G1收集器采用此方案

### 9.5 三色标记的优势

- **支持并发标记**：减少STW时间，提高应用响应速度
- **标记效率高**：通过颜色区分对象状态，避免重复扫描
- **为现代垃圾收集器奠定基础**：G1、ZGC等先进收集器都基于此算法

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0f6395054ae42a0998c33eea98b8b2a~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1095&h=1155&s=442276&e=png&b=fdfdfd)



## 10. GC 名词概念

### 10.1 垃圾回收的类型

根据回收范围的不同，垃圾回收可以分为以下几种类型：

| 类型 | 描述 | 回收范围 |
|------|------|----------|
| **部分收集（Partial GC）** | 只回收部分堆空间 | 新生代或老年代 |
| **新生代收集（Young GC/Minor GC）** | 只回收新生代 | Eden区、Survivor区 |
| **老年代收集（Major GC/Old GC）** | 只回收老年代 | 老年代 |
| **整堆收集（Full GC）** | 回收整个堆空间 | 新生代、老年代、元空间 |

### 10.2 垃圾回收的触发条件

#### 10.2.1 Minor GC触发条件

- **Eden区空间不足**：当新对象分配时，Eden区空间不足
- **大对象直接进入老年代**：当分配的对象超过Eden区大小

#### 10.2.2 Major GC触发条件

- **老年代空间不足**：当对象从新生代晋升到老年代时，老年代空间不足
- **元空间不足**：当元空间空间不足时

#### 10.2.3 Full GC触发条件

- **调用System.gc()**：显式触发Full GC
- **老年代空间不足**：当Major GC无法释放足够空间
- **空间分配担保失败**：Minor GC前，老年代剩余空间不足以容纳新生代所有对象
- **CMS收集器并发失败**：CMS收集器在并发阶段无法处理所有垃圾

### 10.3 垃圾回收的性能指标

- **吞吐量**：CPU用于执行用户代码的时间占总时间的比例
- **停顿时间**：垃圾回收期间应用程序暂停的时间
- **内存占用**：垃圾回收器本身需要的内存开销
- **回收频率**：垃圾回收发生的频率

### 10.4 垃圾回收的常见问题

- **频繁GC**：可能由内存泄漏、对象创建过快等原因导致
- **Full GC时间过长**：可能由老年代空间不足、大对象过多等原因导致
- **内存碎片**：可能由标记-清除算法导致，影响内存分配效率

## 11. 垃圾回收算法

### 11.1 标记-清除算法

**核心思想**：标记-清除算法是最基础的垃圾收集算法，将垃圾回收分为两个阶段：

1. **标记阶段**：遍历所有对象，标记出需要回收的对象
2. **清除阶段**：回收被标记对象所占用的内存空间

**适用场景**：
- 适用于对象存活率低的场景，如老年代的部分回收
- 适用于对内存碎片不敏感的应用

**优点**：
- 实现简单，不需要移动对象
- 对于大量对象需要回收的场景，效率较高

**缺点**：
- 标记和清除过程效率较低，需要遍历所有对象
- 产生大量不连续的内存碎片，可能导致后续大对象分配失败
- 碎片过多会增加垃圾回收的频率

**工作原理**：
标记-清除算法会标记所有死亡的对象，然后清除它们，留下的存活对象和空闲空间会交错分布，形成内存碎片。

![](https://developer.qcloudimg.com/http-save/9862454/eeeb7395bf13a35400741797f3048283.png)

### 11.2 复制算法

**核心思想**：复制算法将内存空间划分为两个相等的区域，每次只使用其中一个。垃圾收集时，将当前区域中的存活对象复制到另一个区域，然后清除整个当前区域。

**适用场景**：
- 适用于对象存活率低的场景，如新生代的回收
- 适用于对内存分配效率要求高的应用

**优点**：
- 实现简单，运行高效
- 按顺序分配内存，不需要考虑内存碎片
- 内存分配速度快，只需指针碰撞即可

**缺点**：
- 可用内存缩小为原来的一半，空间利用率低
- 对象存活率高时会频繁进行复制操作，效率下降

**工作原理**：
复制算法通过将存活对象复制到新区域，然后清空原区域，避免了内存碎片问题。在新生代中，通常将内存分为Eden区和两个Survivor区，比例为8:1:1，每次只使用Eden和一个Survivor区，这样空间利用率可达90%。

![](https://developer.qcloudimg.com/http-save/9862454/cefd4fa40aabbeea1ffe46b7a4576141.png)

### 11.3 标记-整理算法

**核心思想**：标记-整理算法结合了标记-清除和复制算法的优点，分为三个阶段：

1. **标记阶段**：标记出需要回收的对象
2. **整理阶段**：将所有存活对象压缩到内存的一端，紧凑排列
3. **清除阶段**：清理边界以外的内存空间

**适用场景**：
- 适用于对象存活率高的场景，如老年代的回收
- 适用于对内存碎片敏感的应用

**优点**：
- 解决了标记-清除算法的内存碎片问题
- 空间利用率高，不需要额外的内存空间

**缺点**：
- 需要移动对象，一定程度上降低了效率
- 整理过程中需要暂停用户线程（STW）

**工作原理**：
标记-整理算法通过移动存活对象，使它们紧凑排列，然后清理边界外的内存，既避免了内存碎片，又提高了空间利用率。

![](https://developer.qcloudimg.com/http-save/9862454/9c6691059a9a8fb2e60393aeaa7009e5.png)

### 11.4 分代收集算法

**核心思想**：分代收集算法根据对象的生命周期将内存划分为不同区域，对不同区域采用不同的垃圾收集策略。

**适用场景**：
- 几乎所有现代JVM的默认垃圾收集策略
- 适用于大多数Java应用

**优点**：
- 根据对象特点采用不同策略，提高回收效率
- 减少Full GC的频率，提高应用性能
- 针对性强，优化效果明显

**工作原理**：
1. **新生代**：对象存活率低，采用复制算法，分为Eden区和两个Survivor区
2. **老年代**：对象存活率高，采用标记-清除或标记-整理算法
3. **元空间**：存储类信息，采用专门的回收策略

通过分代收集，Minor GC（新生代回收）频率高但速度快，Major GC（老年代回收）频率低但耗时较长，平衡了回收效率和应用性能。

### 11.5 垃圾回收算法对比

| 算法 | 适用场景 | 优点 | 缺点 |
|------|----------|------|------|
| 标记-清除 | 老年代、对象存活率低 | 实现简单、不需要移动对象 | 产生内存碎片、效率较低 |
| 复制 | 新生代、对象存活率低 | 无内存碎片、分配速度快 | 空间利用率低、对象存活率高时效率下降 |
| 标记-整理 | 老年代、对象存活率高 | 无内存碎片、空间利用率高 | 需要移动对象、效率较低 |
| 分代收集 | 全堆 | 针对性强、效率高 | 实现复杂 |



## 12. GC Root

### 12.1 基本概念

GC Root（Garbage Collection Root）是指在Java虚拟机中被直接引用的对象集合，它们被认为是存活对象，不能被垃圾回收器回收。

### 12.2 GC Root的类型

| 类型 | 描述 | 示例 |
|------|------|------|
| **虚拟机栈中引用的对象** | 栈帧中局部变量表和操作数栈中引用的对象 | 方法参数、局部变量 |
| **方法区中类静态属性引用的对象** | 类的静态字段引用的对象 | `static Object obj = new Object()` |
| **方法区中常量引用的对象** | 常量池中的引用类型常量 | `static final Object obj = new Object()` |
| **Native方法中引用的对象** | 本地方法中引用的Java对象 | JNI调用中的对象引用 |
| **活动线程中的对象** | 当前正在执行的线程对象 | 线程对象本身 |
| **当前类加载器加载的类的对象** | 类加载器引用的类对象 | 加载的类的Class对象 |
| **锁对象** | 被synchronized持有的对象 | `synchronized(obj) { ... }`中的obj |
| **JVM内部对象** | JVM自身使用的对象 | 类加载器、系统类等 |

### 12.3 GC Root的作用

GC Root为垃圾回收器提供了初始的扫描位置，垃圾回收过程如下：

1. **标记阶段**：从GC Root开始，标记所有可达的对象
2. **清除阶段**：回收所有未被标记的对象

### 12.4 GC Root的特点

- **存活对象**：GC Root本身是存活对象，不会被回收
- **动态变化**：GC Root集合会随着程序执行而动态变化
- **扫描起点**：垃圾回收器的扫描过程必须从GC Root开始

### 12.5 可达性分析

可达性分析是垃圾回收的核心算法，其过程如下：

1. **确定GC Root**：识别所有的GC Root对象
2. **标记可达对象**：从GC Root开始，递归标记所有可达的对象
3. **回收不可达对象**：回收所有未被标记的对象

通过可达性分析，垃圾回收器能够准确识别哪些对象是存活的，哪些对象是可以被回收的，从而实现高效的内存回收。



## 13. 垃圾回收器

### 13.1 垃圾回收器概述

垃圾回收器是JVM中负责执行垃圾回收的组件，不同的垃圾回收器采用不同的算法和策略，适用于不同的应用场景。根据回收线程的数量和执行方式，垃圾回收器可以分为以下几类：

| 类型 | 特点 | 适用场景 |
|------|------|----------|
| **串行收集器** | 单线程执行垃圾回收 | 单核CPU环境、客户端应用 |
| **并行收集器** | 多线程执行垃圾回收 | 多核CPU环境、对吞吐量要求高的应用 |
| **并发收集器** | 与用户线程并发执行垃圾回收 | 对延迟要求高的应用、服务器应用 |
| **增量收集器** | 将垃圾回收分解为多个小步骤 | 实时应用、对响应时间要求高的场景 |

### 13.2 Serial收集器

**背景**：Serial收集器是最古老、最基本的垃圾收集器，也是JVM客户端模式下的默认收集器。

**特点**：
- 单线程执行垃圾回收，只使用一个CPU核心
- 新生代采用复制算法，老年代采用标记-整理算法
- 执行过程中会暂停所有用户线程（STW）

**适用场景**：
- 适用于单核CPU环境
- 适用于内存较小的客户端应用
- 适用于对响应时间要求不高的场景

**优点**：
- 实现简单，代码量小
- 单线程执行，没有线程切换开销
- 在单核CPU环境下效率较高

**缺点**：
- 垃圾回收时会暂停所有用户线程，导致应用卡顿
- 在多核CPU环境下，无法充分利用硬件资源
- 不适用于大型服务器应用

### 13.3 Serial Old收集器

**背景**：Serial Old是Serial收集器的老年代版本，主要用于与其他收集器配合使用。

**特点**：
- 单线程执行老年代垃圾回收
- 采用标记-整理算法
- 执行过程中会暂停所有用户线程

**适用场景**：
- 作为CMS收集器的备选方案，当CMS收集失败时使用
- 在JDK 5之前与Parallel Scavenge收集器配合使用
- 适用于小型应用或客户端环境

### 13.4 ParNew收集器

**背景**：ParNew是Serial收集器的并行版本，主要用于与CMS收集器配合使用。

**特点**：
- 多线程执行新生代垃圾回收
- 新生代采用复制算法
- 执行过程中会暂停所有用户线程

**适用场景**：
- 适用于多核CPU环境
- 与CMS收集器配合使用，作为新生代收集器
- 适用于对响应时间有一定要求的服务器应用

**优点**：
- 多线程执行，充分利用多核CPU资源
- 与CMS收集器兼容性好
- 新生代回收速度快

**缺点**：
- 垃圾回收时会暂停所有用户线程
- 线程数量过多时，线程切换开销会影响性能

### 13.5 Parallel Scavenge收集器

**背景**：Parallel Scavenge是一款专注于吞吐量的并行收集器，也称为"吞吐量优先收集器"。

**特点**：
- 多线程执行垃圾回收
- 新生代采用复制算法，老年代采用标记-整理算法
- 执行过程中会暂停所有用户线程
- 支持自适应调节策略，可以根据系统运行情况自动调整内存分配和回收策略

**适用场景**：
- 适用于多核CPU环境
- 适用于对吞吐量要求较高的应用，如科学计算、批处理任务
- 适用于后台服务，对响应时间要求不高的场景

**优点**：
- 高吞吐量，适合计算密集型应用
- 自适应调节能力强，减少人工调优成本
- 多线程执行，充分利用硬件资源

**缺点**：
- 垃圾回收时会暂停所有用户线程
- 对响应时间敏感的应用不友好

### 13.6 Parallel Old收集器

**背景**：Parallel Old是Parallel Scavenge收集器的老年代版本，在JDK 6中引入。

**特点**：
- 多线程执行老年代垃圾回收
- 采用标记-整理算法
- 执行过程中会暂停所有用户线程

**适用场景**：
- 与Parallel Scavenge收集器配合使用，组成"Parallel Scavenge + Parallel Old"的收集器组合
- 适用于对吞吐量要求较高的应用

### 13.7 CMS收集器

**背景**：CMS（Concurrent Mark Sweep）收集器是一款以低延迟为目标的并发收集器，在JDK 5中引入。

**特点**：
- 并发执行垃圾回收，减少STW时间
- 老年代采用标记-清除算法
- 执行过程分为四个阶段：初始标记、并发标记、重新标记、并发清除

**适用场景**：
- 适用于对响应时间要求较高的应用，如Web服务器、电子商务系统
- 适用于多核CPU环境
- 适用于内存较大的服务器应用

**优点**：
- 并发执行，减少STW时间，提高应用响应速度
- 适用于对延迟敏感的应用

**缺点**：
- 采用标记-清除算法，会产生内存碎片
- 对CPU资源敏感，并发执行时会占用部分CPU资源
- 无法处理浮动垃圾，可能导致并发失败
- 老年代空间不足时会触发Full GC，导致长时间STW

### 13.8 G1收集器

**背景**：G1（Garbage First）收集器是Oracle在JDK 7中引入的一款面向服务器端应用的垃圾收集器，在JDK 9中成为默认收集器。

**特点**：
- 采用分区（Region）思想，将堆内存划分为多个大小相等的区域
- 局部采用复制算法，整体采用标记-整理算法，避免内存碎片
- 支持可预测的停顿时间，用户可以设置最大GC停顿时间
- 执行过程包括：年轻代回收、混合回收、Full GC

**适用场景**：
- 适用于大内存、多核CPU环境
- 适用于对响应时间有较高要求的服务器应用
- 适用于需要控制GC停顿时间的场景
- 适用于替代CMS收集器的场景

**优点**：
- 支持可预测的停顿时间，满足实时性要求
- 避免内存碎片，提高内存利用率
- 并发执行，减少STW时间
- 适用于大内存环境

**缺点**：
- 实现复杂，代码量较大
- 在小内存环境下，性能不如其他收集器
- 对CPU资源要求较高

### 13.9 ZGC收集器

**背景**：ZGC（Z Garbage Collector）是Oracle在JDK 11中引入的一款低延迟垃圾收集器，专为大内存、低延迟场景设计。

**特点**：
- 采用彩色指针技术和读屏障
- 并发执行所有垃圾回收阶段，几乎无STW
- 支持TB级内存
- 停顿时间控制在毫秒级别

**适用场景**：
- 适用于超大内存环境（TB级）
- 适用于对延迟要求极高的应用，如金融交易系统、实时数据分析
- 适用于多核CPU环境

**优点**：
- 极低的GC停顿时间，几乎不影响应用运行
- 支持超大内存
- 并发执行，对应用影响小

**缺点**：
- 对CPU资源要求较高
- 实现复杂，维护成本高
- 在小内存环境下，性能不如其他收集器

### 13.10 Shenandoah收集器

**背景**：Shenandoah是Red Hat开发的一款低延迟垃圾收集器，在JDK 12中引入。

**特点**：
- 采用并发标记-整理算法
- 支持并发执行所有垃圾回收阶段
- 停顿时间与堆大小无关

**适用场景**：
- 适用于大内存环境
- 适用于对延迟要求较高的应用
- 适用于多核CPU环境

**优点**：
- 低停顿时间，适合实时应用
- 支持大内存
- 与应用并发执行，影响小

**缺点**：
- 对CPU资源要求较高
- 实现复杂
- 在某些场景下，吞吐量可能不如其他收集器

### 13.11 垃圾回收器比对分析

| 收集器 | 类型 | 新生代算法 | 老年代算法 | 目标 | 适用场景 |
|--------|------|-----------|-----------|------|----------|
| Serial | 串行 | 复制 | 标记-整理 | 简单高效 | 客户端应用 |
| ParNew | 并行 | 复制 | - | 低延迟 | 与CMS配合使用 |
| Parallel Scavenge | 并行 | 复制 | 标记-整理 | 高吞吐量 | 计算密集型应用 |
| CMS | 并发 | - | 标记-清除 | 低延迟 | Web服务器 |
| G1 | 并发 | 复制 | 标记-整理 | 可预测停顿 | 大内存服务器 |
| ZGC | 并发 | - | 标记-整理 | 极低延迟 | 超大内存环境 |
| Shenandoah | 并发 | - | 标记-整理 | 低延迟 | 大内存环境 |

### 13.12 垃圾回收器选择建议

1. **客户端应用**：优先选择Serial收集器，简单高效

2. **对吞吐量要求高的应用**：优先选择Parallel Scavenge + Parallel Old组合

3. **对响应时间要求高的应用**：优先选择G1收集器

4. **超大内存、极低延迟要求**：优先选择ZGC或Shenandoah收集器

5. **传统服务器应用**：可以选择CMS收集器，但建议迁移到G1

6. **多核CPU环境**：避免使用串行收集器，充分利用并行或并发收集器

7. **小内存环境**：选择Serial或ParNew收集器

8. **大内存环境**：选择G1、ZGC或Shenandoah收集器

## 14. GC执行过程与日志分析

### 14.1 GC执行流程

GC回收流程如下：

1. **对象分配**：当新对象产生时，首先会判断Eden区是否有内存空间，如果有，则直接将新对象保存在Eden区。

2. **Minor GC触发**：如果Eden区内存不足，会自动执行Minor GC操作，清理Eden区的无用内存空间。

3. **存活对象处理**：
   - Minor GC后，如果Eden区内存仍不足，会检查Survivor区是否有剩余空间
   - 如果Survivor区有空间，将Eden区部分活跃对象保存在Survivor区
   - 如果Survivor区也没有空间，则将部分存活对象保存在老年代

4. **Major GC/Full GC触发**：如果老年代也满了，会触发Major GC（或Full GC），进行老年代的清理。

5. **OOM异常**：如果老年代执行Full GC后，无法进行对象的保存，则会产生OutOfMemoryError异常。

### 14.2 分代执行过程

#### 14.2.1 内存分配比例
- **新生代**：默认占总堆空间的1/3，包含Eden区和两个Survivor区（From和To），默认比例为8:1:1。
- **老年代**：默认占总堆空间的2/3，存放存活时间较长的对象。

#### 14.2.2 Minor GC执行过程
当Eden区内存不足时，触发Minor GC：

1. **第一次GC**：在Eden区执行GC，存活的对象会被移动到其中一个Survivor分区。

2. **后续GC**：采用复制算法，将Eden和From Survivor区一起清理，存活的对象会被复制到To Survivor区。

3. **对象年龄增长**：对象每移动一次，年龄加1，当对象年龄大于阈值（默认15）时，直接移动到老年代。

4. **动态年龄判断**：如果Survivor区中相同年龄的对象总和超过Survivor区大小的50%（可通过-XX:TargetSurvivorRatio调整），则年龄大于等于该年龄的对象直接进入老年代。

5. **空间分配担保**：如果Survivor区内存不足，会使用老年代空间作为担保。

6. **大对象直接进入老年代**：超过指定大小的对象（可通过-XX:PretenureSizeThreshold调整）可以直接进入老年代。

### 14.3 Full GC触发条件

Full GC是对整个堆空间的垃圾收集，触发条件包括：

1. **晋升失败**：每次晋升到老年代的对象平均大小 > 老年代剩余空间

2. **空间分配担保失败**：Minor GC后存活的对象超过了老年代剩余空间

3. **元空间不足**：元空间内存不足时

4. **显式触发**：调用System.gc()可能会引起Full GC

5. **CMS收集器异常**：
   - promotion failed：Minor GC时，Survivor空间放不下，对象只能放入老年代，而老年代也放不下
   - concurrent mode failure：CMS收集器在并发阶段，老年代空间不足

6. **大对象分配**：堆内存分配很大的对象，直接进入老年代但老年代空间不足

### 14.4 GC日志分析

#### 14.4.1 GC日志格式详解

GC日志是JVM垃圾回收过程的详细记录，包含了垃圾回收的类型、时间、内存变化等重要信息，是分析JVM性能和排查内存问题的重要依据。

**G1收集器日志示例：**

```
[346.934s][info ][gc,start    ] GC(271) Pause Young (Normal) (G1 Evacuation Pause)
[346.934s][info ][gc,task     ] GC(271) Using 8 workers of 8 for evacuation
[346.937s][info ][gc,phases   ] GC(271)   Pre Evacuate Collection Set: 0.1ms
[346.937s][info ][gc,phases   ] GC(271)   Merge Heap Roots: 0.1ms
[346.937s][info ][gc,phases   ] GC(271)   Evacuate Collection Set: 1.8ms
[346.937s][info ][gc,phases   ] GC(271)   Post Evacuate Collection Set: 0.6ms
[346.937s][info ][gc,phases   ] GC(271)   Other: 0.2ms
[346.937s][info ][gc,heap     ] GC(271) Eden regions: 426->0(426)
[346.937s][info ][gc,heap     ] GC(271) Survivor regions: 4->4(54)
[346.937s][info ][gc,heap     ] GC(271) Old regions: 170->170
[346.937s][info ][gc,heap     ] GC(271) Archive regions: 2->2
[346.937s][info ][gc,heap     ] GC(271) Humongous regions: 0->0
[346.937s][info ][gc,metaspace] GC(271) Metaspace: 59579K(60096K)->59579K(60096K) NonClass: 52231K(52480K)->52231K(52480K) Class: 7348K(7616K)->7348K(7616K)
[346.937s][info ][gc          ] GC(271) Pause Young (Normal) (G1 Evacuation Pause) 1200M->347M(1434M) 2.672ms
```

#### 14.4.2 GC日志各部分含义

| 日志部分 | 含义 | 示例 |
|---------|------|------|
| 时间戳 | GC发生的时间点，从JVM启动开始计算 | [346.934s] |
| 日志级别 | 日志的级别，通常为info | [info] |
| GC类型 | GC的类型，如gc,start、gc,task、gc,phases等 | [gc,start] |
| GC ID | 当前GC的唯一标识符 | GC(271) |
| 具体操作 | GC执行的具体操作 | Pause Young (Normal) (G1 Evacuation Pause) |
| 工作线程 | GC使用的工作线程数 | Using 8 workers of 8 for evacuation |
| 阶段耗时 | GC各阶段的执行时间 | Pre Evacuate Collection Set: 0.1ms |
| 内存变化 | 各内存区域的使用情况变化 | Eden regions: 426->0(426) |
| 总内存变化 | 整个堆内存的使用情况变化 | 1200M->347M(1434M) |
| 总耗时 | GC的总执行时间 | 2.672ms |

#### 14.4.3 不同GC类型的日志特点

| GC类型 | 日志特点 | 示例 |
|--------|---------|------|
| Minor GC | 只涉及新生代，耗时较短 | Pause Young (Normal) (G1 Evacuation Pause) |
| Major GC | 只涉及老年代，耗时较长 | Pause Old (G1 Evacuation Pause) |
| Full GC | 涉及整个堆，耗时最长 | Pause Full (System.gc()) |

#### 14.4.4 常见GC日志分析点

1. **GC频率**：观察GC发生的频率，是否过于频繁
2. **GC耗时**：分析GC的执行时间，是否超过预期
3. **内存变化**：关注各内存区域的使用情况变化，是否有异常
4. **晋升失败**：是否有晋升失败的情况，导致Full GC
5. **并发失败**：CMS收集器是否有并发失败的情况
6. **内存碎片**：老年代是否有严重的内存碎片问题

#### 14.4.5 GC日志相关参数

| 参数 | 描述 | 适用版本 |
|------|------|----------|
| -XX:+PrintGCDetails | 打印详细GC日志 | JDK 8及以下 |
| -XX:+PrintGCDateStamps | 打印GC时间戳 | JDK 8及以下 |
| -XX:+PrintHeapAtGC | GC前后打印堆信息 | 所有版本 |
| -Xlog:gc* | 开启GC日志 | JDK 9+ |
| -Xlog:gc*:file=gc.log | GC日志输出到文件 | JDK 9+ |
| -XX:+PrintReferenceGC | 打印引用处理信息 | 所有版本 |

### 14.5 垃圾回收器性能对比

| 收集器 | 最大停顿时间 | 吞吐量 | 内存开销 | 适用场景 |
|--------|-------------|--------|----------|----------|
| Serial | 较长 | 一般 | 低 | 客户端应用 |
| ParNew | 中等 | 较高 | 低 | 与CMS配合使用 |
| Parallel Scavenge | 较长 | 高 | 低 | 计算密集型应用 |
| CMS | 短 | 中等 | 中等 | Web服务器 |
| G1 | 可预测 | 较高 | 较高 | 大内存服务器 |
| ZGC | 极短 | 中等 | 高 | 超大内存环境 |
| Shenandoah | 极短 | 中等 | 高 | 大内存环境 |

### 14.6 GC调优建议

1. **根据应用特点选择收集器**：
   - 客户端应用：Serial收集器
   - 计算密集型应用：Parallel Scavenge + Parallel Old
   - 响应时间敏感应用：G1收集器
   - 超大内存应用：ZGC或Shenandoah收集器

2. **合理设置内存大小**：
   - 新生代大小：根据对象创建速率和生命周期调整
   - 老年代大小：根据对象晋升速率调整
   - 避免内存设置过小导致频繁GC

3. **优化对象分配**：
   - 减少大对象的创建
   - 合理使用对象池
   - 避免内存泄漏

4. **监控与分析**：
   - 定期分析GC日志
   - 使用JVM监控工具（如JConsole、VisualVM）
   - 根据实际情况调整GC参数

### 14.5 安全点与安全区域

#### 14.5.1 安全点（SafePoint）

**概念**：安全点是指程序执行过程中的一些特定位置，当线程执行到这些位置时，状态是确定的，JVM可以安全地暂停线程进行GC。

**选择位置**：
- 方法调用
- 循环跳转
- 异常跳转
- 其他具有长时间执行特征的指令序列

**实现方式**：
- **抢占式中断**：JVM主动中断线程，检查是否在安全点
- **主动式中断**：线程执行到安全点时，主动检查是否需要暂停

#### 14.5.2 安全区域（Safe Region）

**概念**：安全区域是指一段代码片段，其中的引用关系不会发生变化，线程可以在任何位置安全地暂停。

**应用场景**：
- 线程处于Sleep状态
- 线程处于Blocked状态
- 其他无法快速响应中断的场景

**工作原理**：
1. 线程进入安全区域前，标记自己进入安全区域
2. GC发生时，不需要等待这些线程
3. 线程离开安全区域时，检查是否完成GC，如果未完成则等待

### 14.6 总结

JVM垃圾回收是一个复杂而精细的过程，涉及多种算法和收集器。通过合理选择垃圾回收器、调整GC参数、优化对象分配，可以显著提高Java应用的性能和稳定性。

**核心要点**：
- 理解垃圾回收的基本原理和算法
- 根据应用特点选择合适的垃圾回收器
- 监控和分析GC日志，及时发现和解决问题
- 持续优化内存使用，减少GC压力
- 关注JVM技术的发展，如ZGC和Shenandoah等新一代收集器

通过本指南的学习，希望你能对JVM垃圾回收机制有更深入的理解，从而编写出更高效、更稳定的Java应用。





## 内存分配

大对象直接进老年代 

https://blog.csdn.net/zhou920786312/article/details/123536294



## 初始过程 

**比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，他们的执行顺序**

先静态、先父后子。

先静态：父静态 > 子静态

优先级：父类 > 子类 静态代码块 > 非静态代码块 > 构造函数



## SafePoint

https://zhuanlan.zhihu.com/p/286110609

### 安全点 

STW并不会只发生在内存回收的时候。现在程序员这么卷，碰到几次safepoint的问题几率也是比较大的。

当发生GC时，用户线程必须全部停下来，才可以进行垃圾回收，这个状态我们可以认为JVM是安全的（safe），整个堆的状态是稳定的。

如果在GC前，有线程迟迟进入不了safepoint，那么整个JVM都在等待这个阻塞的线程，造成了整体GC的时间变长。





- 现在可达性分析算法耗时最长的查找引用链的过程已经可以做到与用户线程一起并发，但根节点枚举始终还是必须在一个能保障一致性的快照中才得以进行

- 即使是号称停顿时间可控，或者（几乎）不会发生停顿的CMS、G1、 ZGC等收集器，枚举根节点时也是必须要停顿的



- 用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集，而是强制要求必须执行到达安全点后才能够暂停。



### 选择标准

安全点位置的选择标准是：是否能让程序长时间执行；所以会在方法调用、循环跳转、异常跳转等处才会产生安全点

HotSpot会在所有方法的临返回之前，以及所有非counted loop的循环的回跳之前放置安全点。

“长时间执行”的最明显特征就是指令序列的复用，例如方法调用、循环跳转、异常跳转 等都属于指令序列复用，所以只有具有这些功能的指令才会产生安全点。





### 中断停顿

- 抢先式中断

“抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就”

“恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。

- 主动式中断

而主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。”



### 安全域

“使用Safepoint似乎已经完美地解决了如何进入GC的问题，但实际情况却并不一定。Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？所谓的程序不执行就是没有分配CPU时间，典型的例子就是线程处于Sleep状态或者Blocked状态，这时候线程无法响应JVM的中断请求，“走”到安全的地方去中断挂起，JVM也显然不太可能等待线程重新被分配CPU时间。对于这种情况，就需要安全区域（Safe Region）来解决。”





## MAT

参考链接 https://c.m.163.com/news/a/HL40JTCI0552ZNXL.html

入门 https://juejin.cn/post/6908665391136899079

进阶 https://juejin.cn/post/6911624328472133646

官网 https://help.eclipse.org/latest/index.jsp?topic=/org.eclipse.mat.ui.help/welcome.html





### 概况

Leak Suspects 》 System Overview

- Heap Dump Overview 
- System Properties
- Thread Overview
- Top Consumers
  - Biggest Objects (Overview)
  - Biggest Objects
  - Biggest Top-Level Dominator Classes (Overview)
  - Biggest Top-Level Dominator Classes
  - Biggest Top-Level Dominator Class Loaders (Overview)
  - Biggest Top-Level Dominator Class Loaders
  - Biggest Top-Level Dominator Packages
- Class Histogram



## 架构



## Bilibili 

根据你的需求，我梳理了JVM字节码增强技术的要点，下面这个表格汇总了最核心的知识板块，并会逐个展开。

📚 字节码增强技术核心要点概览

字节码增强的本质
一类对现有字节码进行修改或动态生成全新字节码文件的技术。

主流技术实现

· ASM: 底层、高性能，直接操作JVM指令，适合对性能要求高的场景。
· Javassist: 提供源码级API，易于上手，牺牲部分性能换取开发效率。
· Java Agent: 通过Instrumentation API实现无侵入的类加载时/运行时字节码修改，是生产级应用的主要方式。

关键应用场景

· APM（应用性能监控）: 无侵入地监控方法耗时、调用链。
· AOP（面向切面编程）: 实现日志、事务管理等。
· 热部署与调试: 如Arthas等在线诊断工具。
· 框架底层: Spring AOP (CGLIB)、Lombok等均基于此技术。

接下来，我将针对你提出的几个方面进行详细说明。

1. 面试知识点汇总

基础概念

· 字节码(Bytecode)：JVM的中间指令，.class文件的二进制格式，是“一次编译，到处运行”的基石。
· 字节码结构：了解.class文件结构是基础，主要包括：
  · 魔数 (CAFEBABE)
  · 版本号
  · 常量池 (资源仓库)
  · 访问标志
  · 类/父类/接口索引
  · 字段表
  · 方法表 (核心，含Code属性存储JVM指令)。
· JVM执行模型：理解基于栈的虚拟机（vs 基于寄存器），以及栈帧(Stack Frame)中的局部变量表和操作数栈如何协作执行字节码指令。

增强技术与框架

· ASM：
  · 核心思想：基于访问者模式，直接操作JVM指令，性能高。
  · 核心API：
    · ClassReader：读取字节码。
    · ClassWriter：写入或生成新字节码。
    · ClassVisitor, MethodVisitor：访问并修改类、方法结构。
· Javassist：
  · 核心思想：提供源码级API，使用字符串拼接Java代码即可修改类，易用性高。
  · 核心类：
    · ClassPool：CtClass对象容器。
    · CtClass：类的抽象表示。
    · CtMethod, CtField：方法和字段的抽象表示。
· Java Agent与Instrumentation：
  · 核心机制：JVM提供的JVMTI接口的Java端实现，允许在类加载时或运行时对其字节码进行转换。
  · 关键方法：
    · premain：在main方法之前执行，用于类加载时增强。
    · agentmain：在JVM启动后动态附着，用于运行时增强（如Arthas）。
    · ClassFileTransformer：定义字节码转换逻辑的核心接口。

2. 面试问题汇总与答案解析

Q1：什么是字节码增强？它有什么用处？

· 答：字节码增强是一类对现有Java字节码进行修改或动态生成全新字节码文件的技术。主要用途包括：
  1. 实现AOP：如Spring AOP底层通过CGLIB（基于ASM）为方法添加事务、日志等切面。
  2. 应用监控：无侵入地收集方法性能数据、调用链路，如APM工具SkyWalking。
  3. 热部署与调试：修改已加载类的行为，用于线上诊断（Arthas）或开发热部署。
  4. 动态生成/修改类：如Lombok在编译时生成getter/setter方法。

Q2：对比ASM和Javassist，它们各有什么优缺点？适合什么场景？

· 答：
  · ASM
    · 优点：直接操作字节码指令，性能极高；功能强大且精细，几乎可进行任何合法的字节码操作。
    · 缺点：学习曲线陡峭，需要熟悉JVM指令和访问者模式；代码可读性差。
    · 场景：对性能有极致要求的框架底层（如CGLIB）、高性能APM探针。
  · Javassist
    · 优点：使用类似Java源代码的字符串进行编程，API简单，开发效率高，易于上手。
    · 缺点：性能通常低于ASM；在修改复杂字节码结构（如泛型、注解）时可能受限。
    · 场景：需要快速原型开发、对性能要求不是极致的AOP实现、动态类生成工具。

Q3：如何实现一个Java Agent来进行字节码增强？简述其核心步骤。

· 答：
  1. 编写Agent类：创建包含premain或agentmain方法的类。
  2. 实现ClassFileTransformer：在其中使用ASM或Javassist编写具体的字节码修改逻辑。
  3. 注册Transformer：在premain/agentmain方法中，通过Instrumentation.addTransformer()注册上述转换器。
  4. 打包MANIFEST.MF：在jar包的META-INF/MANIFEST.MF中指定Premain-Class或Agent-Class属性。
  5. 加载Agent：通过JVM启动参数-javaagent:xxx.jar（对于premain）或使用Attach API（对于agentmain）动态加载。

3. 高阶使用

Java Agent的Attach机制实现运行时增强

· 除了启动时加载，Java Agent支持通过Attach API（com.sun.tools.attach）动态连接到正在运行的JVM进程，并调用agentmain方法加载代理，实现无需重启的字节码增强。这是在线诊断工具（如Arthas）的核心技术。

使用ASM的Tree API进行复杂分析

· ASM除了流式处理的Core API，还提供了Tree API。它将整个类的结构以树形结构（类似于DOM解析XML）读入内存，方便进行复杂的分析、重构或随机访问修改，虽然更耗内存，但在某些场景下编程更直观。

字节码增强的性能与稳定性考量

· 在生产环境中使用字节码增强（特别是通过Java Agent）时，必须高度重视：
  1. 性能开销：每一个被增强的方法都会增加额外的指令执行，需评估其对RT（响应时间）的影响。通常使用高效的ASM并尽量减少注入的代码量。
  2. 类隔离：确保增强逻辑使用的类库与目标应用类库无冲突，防止类污染。可使用独立的ClassLoader。
  3. 异常处理：增强后的代码不能破坏原有的异常处理逻辑，要确保栈帧和局部变量表的正确性。

4. 注意事项、优点和不足

优点

1. 无侵入性：无需修改源代码，即可为程序添加新功能，符合“开闭原则”。
2. 灵活性高：可在程序生命周期的不同阶段（编译时、类加载时、运行时）进行干预。
3. 功能强大：能够实现传统编码难以或无法实现的功能，如深度监控、热修复等。

不足与风险

1. 技术门槛高：需要深入理解JVM字节码、类文件结构和类加载机制。
2. 调试困难：增强后的字节码难以直接调试，问题定位复杂。
3. 兼容性风险：不同JVM版本、类库版本的字节码细节可能有差异，增强代码需要充分测试。
4. 性能影响：不当的增强会显著增加方法调用开销和内存占用。
5. 稳定性风险：错误的字节码修改可能导致JVM验证失败、类加载错误或程序崩溃。

注意事项

1. 保持最小化影响：只增强必要的类和方法，注入最精简的代码。
2. 充分测试：必须在目标环境进行全面测试，包括功能、性能和压力测试。
3. 理解目标类：增强前需彻底了解被增强类的原有逻辑，避免破坏其语义。

5. 开源文章与场景文档汇总

· 美团技术团队《字节码增强技术探索》：系统介绍了字节码结构、ASM/Javassist使用及Java Agent原理，内容详实，是很好的入门和进阶资料。
· 实践案例《ASM字节码编程 | 用字节码增强技术给所有方法加上TryCatch》：通过一个为方法统一添加监控逻辑的具体案例，详细展示了ASM的编码过程，非常有实践价值。
· 面试与原理《京东面试：什么是字节码增强？》和《十分钟拿下JVM字节码指令面试题》：从面试角度剖析核心概念，帮助理解字节码指令与JVM运行时栈帧。
· 官方/社区文档：
  · ASM官方文档：https://asm.ow2.io/
  · Javassist官方教程：https://www.javassist.org/tutorial/tutorial.html
  · Oracle JVM Tool Interface (JVMTI) 文档：https://docs.oracle.com/javase/8/docs/platform/jvmti/jvmti.html

使用场景总结：

· 框架开发：Spring (AOP, 事务)、MyBatis (动态SQL)、Lombok。
· 应用性能管理(APM)：SkyWalking, Pinpoint 等探针。
· 在线诊断与热部署：Arthas, JRebel。
· 测试与Mock：动态生成测试类或Mock类。

这些信息应该能够为你提供一个全面的JVM字节码增强技术图谱。你是否对其中某个特定框架（如ASM的Core API细节）或应用场景（如如何设计一个简单的Java Agent）有更深入的兴趣？

## 参考链接 

JVM 知识汇总 https://juejin.cn/post/7303386068606812199

GC 解析 https://juejin.cn/post/7303414348932382774



jvm参数配置 https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html

内容解析 https://www.zhihu.com/column/c_1268282634804400128

加载过程解析 https://my.oschina.net/u/4090830/blog/10141305



【itv】https://github.com/whx123/JavaHome/blob/master/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E7%BB%93%E5%8F%B7/JVM%20%E7%AF%87/JVM%E9%9D%A2%E8%AF%95%E9%A2%98.md

【itv2】

https://github.com/rbmonster/learning-note/blob/master/src/main/java/com/toc/JVM.md



https://blog.csdn.net/zouliping123456/article/details/124522802

https://blog.csdn.net/weixin_59262008/article/details/125676787

https://zhuanlan.zhihu.com/p/375202547

https://www.cnblogs.com/hanease/p/15869727.html