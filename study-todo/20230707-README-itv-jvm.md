# JVM深度解析与实践指南

## 目录

### 第一部分：JVM基础
1. [简介](#1-简介)
2. [JVM背景与历史](#2-jvm背景与历史)
3. [JVM架构](#3-jvm架构)

### 第二部分：字节码与类加载
4. [字节码文件](#4-字节码文件)
5. [类加载过程](#5-类加载过程)
6. [对象初始化](#6-对象初始化)
7. [字节码技术](#7-字节码技术)

### 第三部分：内存管理与垃圾回收
8. [内存分配方式](#8-内存分配方式)
9. [GC 名词概念](#9-gc-名词概念)
10. [GC Root](#10-gc-root)
11. [三色标记](#11-三色标记)
12. [垃圾回收算法](#12-垃圾回收算法)
13. [垃圾回收器](#13-垃圾回收器)
14. [GC执行过程与日志分析](#14-gc执行过程与日志分析)

### 第四部分：调优与工具
15. [JVM参数解析](#15-jvm参数解析)

## 1. 简介

本指南详细介绍Java虚拟机（JVM）的核心概念、工作原理、垃圾回收机制以及性能调优策略，旨在帮助开发者深入理解JVM内部机制，从而编写更高效的Java应用并进行有效的性能优化。

主要聚焦于HotSpot JVM，这是目前应用最广泛的JVM实现。

## 2. JVM背景与历史

### 2.1 发展历程

JVM（Java Virtual Machine）的历史可以追溯到1990年代初，当时Sun Microsystems公司的James Gosling领导的团队开始开发一种名为"Green Project"的编程语言，旨在为消费电子产品创建一种可移植的编程解决方案。

1. **1991年**：Green Project启动，开发了一种名为Oak的编程语言，这是Java的前身。

2. **1995年**：Sun正式发布Java 1.0，同时推出了JVM规范。JVM的设计理念是"一次编写，到处运行"（Write Once, Run Anywhere），通过将Java代码编译为字节码，然后由不同平台上的JVM解释执行，实现了跨平台兼容性。

3. **1997年**：Java 1.1发布，引入了JIT（Just-In-Time）编译器，显著提高了Java程序的执行效率。

4. **2000年**：Java 2平台发布，包括J2SE、J2EE和J2ME三个版本，JVM也得到了相应的增强。

5. **2006年**：Sun宣布Java技术开源，成立了OpenJDK项目，JVM的开发开始由社区共同参与。

6. **2009年**：Oracle收购Sun Microsystems，成为Java和JVM的新所有者。

7. **2014年**：Java 8发布，引入了Lambda表达式、Stream API等重要特性，同时JVM在性能和垃圾回收方面也有了显著改进。

8. **2018年**：Java 11发布，这是第一个长期支持（LTS）版本，同时引入了ZGC等新的垃圾回收器。

9. **2021年**：Java 17发布，这是最新的LTS版本，进一步增强了JVM的性能和功能。

### 2.2 技术演进

JVM的技术演进主要体现在以下几个方面：

1. **执行引擎优化**：从最初的纯解释执行，到引入JIT编译器，再到分层编译（Tiered Compilation），不断提高Java程序的执行效率。

   ### 执行引擎演进流程图

   ```mermaid
   flowchart TD
       A[Java源代码] --> B[编译为字节码]
       B --> C{执行方式选择}
       
       subgraph 纯解释执行
       C1[解释器逐行翻译字节码]
       C1 --> D1[实时执行机器码]
       end
       
       subgraph JIT编译
       C2[热点探测]
       C2 --> D2[识别频繁执行代码]
       D2 --> E2[JIT编译为优化机器码]
       E2 --> F2[缓存并执行编译后代码]
       end
       
       subgraph 分层编译
       C3[分层编译策略]
       C3 --> D3[第0层：纯解释执行+收集统计信息]
       D3 --> E3{代码热度检查}
       E3 -->|热点代码| F3[第1层：C1快速编译]
       F3 --> G3{进一步优化}
       G3 -->|需要更多优化| H3[第2层：C1带profiling编译]
       H3 --> I3[第3层：C2深度优化编译]
       end
       C -->|默认策略| C3
   ```
   
   **纯解释执行**：
   
   - **基本概念**：解释器逐行读取字节码指令，实时翻译成机器码并执行
- **原理**：无需编译过程，直接执行字节码
   - **优点**：启动速度快，内存占用小
   - **缺点**：执行效率低，无法充分利用硬件性能
   - **注意事项**：适用于启动时间敏感、执行时间短的应用场景
   
   **JIT编译器**：
   
- **基本概念**：Just-In-Time编译器，将热点代码（频繁执行的代码）编译为本地机器码并缓存
   - **原理**：通过热点探测识别频繁执行的代码片段，将其编译为优化的机器码
   - **优点**：热点代码执行效率接近原生代码，大幅提升应用性能
   - **缺点**：编译过程需要时间和内存，可能影响启动速度
   - **注意事项**：编译开销与执行收益需要平衡，适用于长时间运行的应用
   
   **分层编译**：
- **基本概念**：结合了解释器和JIT编译器的优点，将编译过程分为多个层次
   - **原理**：
     - 第0层：纯解释执行，收集执行统计信息
     - 第1层：C1编译器（客户端编译器），快速编译出简单优化的代码
     - 第2层：C1编译器，带有 profiling 的编译
     - 第3层：C2编译器（服务器编译器），进行深度优化的编译
   - **优点**：兼顾启动速度和执行效率，根据代码热度动态调整编译策略
   - **缺点**：实现复杂，内存占用较大
   - **注意事项**：默认开启，适用于大多数应用场景，可通过-XX:-TieredCompilation关闭
   
2. **内存管理改进**：从早期的**简单内存模型，到分代收集，再到G1、ZGC等先进的垃圾回收器**，内存管理的效率和可靠性不断提升。

3. **并发处理增强**：引入了更高效的并发数据结构和同步机制，支持更大规模的并发应用。

4. **安全性提升**：不断加强JVM的安全机制，防止恶意代码的执行。

5. **工具链完善**：提供了丰富的监控、诊断和调优工具，如JConsole、VisualVM、JMC等，帮助开发者更好地理解和优化JVM的运行状态。

### 2.3 重要的JVM实现

除了Oracle的HotSpot JVM外，还有其他一些重要的JVM实现：

| JVM实现 | 开发方 | 特点 | 适用场景 |
|--------|-------|------|----------|
| HotSpot | Oracle | 高性能、功能丰富，主流JVM实现 | 大多数Java应用 |
| OpenJ9 | Eclipse基金会 | 低内存占用、快速启动 | 云原生应用、微服务 |
| GraalVM | Oracle | 支持多语言、AOT编译 | 多语言混合开发、高性能计算 |
| Azul Zing | Azul Systems | 低延迟、可预测性强 | 金融交易系统、实时应用 |
| BEA JRockit | Oracle (已整合到HotSpot) | 高性能、低延迟 | 已不再单独使用 |

## 3. JVM架构

### 3.1 整体架构

JVM架构由以下几个主要部分组成：

![](https://images0.cnblogs.com/i/288799/201405/281726404166686.jpg)

### 3.2 内存结构

JVM内存结构分为以下几个区域：

#### 3.2.1 程序计数器

程序计数器（Program Counter Register）是一块较小的内存空间，用于保存程序当前执行的指令地址。

- **功能**：当CPU需要执行指令时，从程序计数器中获取当前指令的地址，执行完毕后自动更新为下一条指令的地址。
- **特点**：
  - 线程私有，每个线程都有自己独立的程序计数器
  - 如果线程执行的是非native方法，保存的是当前指令的地址
  - 如果线程执行的是native方法，值为undefined
  - 不会发生内存溢出（OutOfMemoryError）

#### 3.2.2 Java虚拟机栈

Java虚拟机栈（Java Virtual Machine Stack）是Java方法执行的内存模型，每个方法执行时都会创建一个栈帧。

- **栈帧组成**：
  - 局部变量表：存储方法参数和局部变量
  - 操作数栈：用于方法执行过程中的计算
  - 动态链接：指向运行时常量池的引用
  - 方法返回地址：方法执行完毕后返回的地址

- **特点**：
  - 线程私有
  - 栈深度有限，过深会导致StackOverflowError
  - 内存不足时会抛出OutOfMemoryError

#### 3.2.3 本地方法栈

本地方法栈（Native Method Stack）与Java虚拟机栈类似，但是为执行本地（Native）方法服务。

- **特点**：
  - 线程私有
  - 在HotSpot JVM中，本地方法栈与Java虚拟机栈合二为一
  - 同样可能抛出StackOverflowError和OutOfMemoryError

#### 3.2.4 堆

堆（Heap）是JVM中最大的内存区域，用于存储对象实例和数组。

- **特点**：
  - 线程共享
  - 垃圾收集器的主要工作区域
  - 内存不足时会抛出OutOfMemoryError

- **堆空间划分**：
  - 新生代（Young Generation）：对象新建区域，分为Eden区和两个Survivor区（From和To）
  - 老年代（Old Generation）：存放存活时间较长的对象
  - 元空间（Metaspace）：JDK 8+中替代永久代，存储类元数据

#### 3.2.5 方法区

方法区（Method Area）用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

- **特点**：
  - 线程共享
  - 在JDK 7及之前称为永久代（Permanent Generation）
  - 在JDK 8及之后被元空间（Metaspace）替代
  - 内存不足时会抛出OutOfMemoryError

### 3.3 执行引擎

执行引擎负责执行字节码，主要包括以下组件：

- **解释器**：逐行解释执行字节码，启动速度快
- **JIT编译器**：将热点代码编译为本地机器码，提高执行效率
- **垃圾回收器**：自动回收不再使用的内存



## 4. 字节码文件

### 4.1 文件结构

Java字节码文件（.class文件）是一种二进制格式文件，包含了以下主要结构：

- **魔数**：0xCAFEBABE，用于识别.class文件
- **版本号**：包含主版本号和次版本号
- **常量池**：存储字面量和符号引用
- **访问标志**：标识类的访问权限和属性
- **类索引、父类索引和接口索引**：确定类的继承关系
- **字段表集合**：描述类的字段信息
- **方法表集合**：描述类的方法信息
- **属性表集合**：存储类的附加信息

![](https://pdai.tech/images/jvm/java-jvm-class-2.png)

### 4.2 反编译工具

使用`javap`命令可以反编译.class文件，查看其内部结构：

```bash
# 查看详细信息，包括常量池、方法表等
javap -verbose -p Main.class

# 编译Java文件
javac HelloTest.java
```



## 5. 类加载过程

### 5.1 概述

Java程序的运行过程可以分为三个主要阶段：**编译 → 类加载 → 执行**。

类加载是JVM将.class文件加载到内存并转换为运行时数据结构的过程，是Java程序运行的基础。

![](https://oss.javaguide.cn/github/javaguide/java/basis/jvm-rough-structure-model.png)

### 5.2 类加载流程图

以下是类加载的详细流程：

```mermaid
flowchart TD
    A[加载阶段 Loading] --> B[连接阶段 Linking]
    B --> C[初始化阶段 Initialization]
    
    subgraph 加载阶段
    A1[通过类名获取二进制字节流] --> A2[将字节流转换为方法区运行时数据结构]
    A2 --> A3[在内存中生成Class对象作为访问入口]
    end
    
    subgraph 连接阶段
    B1[验证阶段 Verification] --> B2[准备阶段 Preparation]
    B2 --> B3[解析阶段 Resolution]
    
    B11[文件格式验证] --> B1
    B12[元数据验证] --> B1
    B13[字节码验证] --> B1
    B14[符号引用验证] --> B1
    
    B21[为静态变量分配内存] --> B2
    B22[设置默认初始值] --> B2
    
    B31[将符号引用转换为直接引用] --> B3
    end
    
    subgraph 初始化阶段
    C1[执行静态代码块] --> C2[为静态变量赋予程序中定义的初始值]
    end
```

类加载过程的核心步骤包括：
1. **加载阶段**：获取字节码、转换数据结构、生成Class对象
2. **连接阶段**：验证字节码合法性、准备静态变量内存、解析符号引用
3. **初始化阶段**：执行静态代码块、初始化静态变量

这个流程确保了类在使用前被正确加载和初始化，为Java程序的运行提供了基础。

### 5.3 类加载的主要过程

类加载过程由JVM负责，主要分为三个阶段：

#### 5.3.1 加载（Loading）

- **功能**：将编译完成的.class二进制文件加载到内存，生成对应的Class对象。
- **过程**：
  1. 通过类的全限定名获取.class文件的二进制字节流
  2. 将字节流所代表的静态存储结构转换为方法区的运行时数据结构
  3. 在内存中生成一个代表该类的Class对象，作为方法区中该类数据的访问入口

- **类加载器**：
  - Bootstrap ClassLoader：加载Java核心类库
  - Extension ClassLoader：加载扩展类库
  - Application ClassLoader：加载应用程序类
  - 自定义类加载器：根据需要自定义加载逻辑

#### 5.3.2 连接（Linking）

连接阶段是将加载到内存的类的二进制数据合并到JVM的运行时环境中，分为三个步骤：

##### 5.3.2.1 验证（Verification）

- **功能**：确保加载的类符合JVM规范，保证安全性。
- **验证内容**：
  - 文件格式验证：确保.class文件格式正确
  - 元数据验证：验证类的元数据信息
  - 字节码验证：验证字节码指令的合法性
  - 符号引用验证：验证符号引用的有效性

##### 5.3.2.2 准备（Preparation）

- **功能**：为类的静态变量分配内存，并设置默认初始值。
- **特点**：
  - 只为静态变量分配内存，不包括实例变量
  - 初始值为JVM默认值，而非程序中定义的初始值
  - 例如：int类型默认值为0，boolean类型默认值为false，引用类型默认值为null

##### 5.3.2.3 解析（Resolution）

- **功能**：将类中的符号引用转换为直接引用。
- **概念**：
  - 符号引用：以字符串形式表示的引用，如方法名、字段名
  - 直接引用：指向目标的指针、偏移量或句柄
- **解析对象**：类、接口、字段、方法等

#### 5.3.3 初始化（Initialization）

- **功能**：为类的静态变量赋予程序中定义的初始值，并执行静态代码块。
- **触发条件**：
  - 创建类的实例 new关键词
  - 调用类的静态方法
  - 访问类的静态字段
  - 反射调用
  - 初始化子类时，父类会先初始化
  - 执行main方法的类

- **执行顺序**：
  1. 父类静态变量和静态代码块
  2. 子类静态变量和静态代码块
  3. 父类实例变量和实例代码块
  4. 父类构造方法
  5. 子类实例变量和实例代码块
  6. 子类构造方法



## 6. 对象初始化

### 6.1 对象创建流程图

以下是Java对象创建的完整流程：

```mermaid
flowchart TD
    A[遇到new指令] --> B[类加载检查]
    B -->|类未加载| C[执行类加载过程]
    B -->|类已加载| D[分配内存]
    C --> D
    D --> E[初始化零值]
    E --> F[设置对象头]
    F --> G[执行<init>方法]
    G --> H[对象创建完成]
    
    subgraph 内存分配方式
    D1[指针碰撞] --> D
    D2[空闲列表] --> D
    end
    
    subgraph 线程安全处理
    D3[CAS机制] --> D
    D4[TLAB分配] --> D
    end
    
    subgraph 对象头信息
    F1[运行时数据] --> F
    F2[类型指针] --> F
    F3[偏向锁标志] --> F
    end
    
    subgraph 初始化过程
    G1[执行构造方法] --> G
    G2[初始化实例变量] --> G
    G3[调用父类构造方法] --> G
    end
```

### 6.2 对象创建的详细过程

Java对象的创建过程主要包括以下步骤：

#### 6.2.1 类加载检查

当JVM遇到一条`new`指令时，首先会检查：

- 指令参数是否能在常量池中定位到一个类的符号引用
- 该符号引用代表的类是否已被加载、解析和初始化

如果类尚未加载，则需要先执行类加载过程。

#### 6.2.2 分配内存

类加载检查通过后，JVM为新生对象分配内存：

- **内存大小**：对象所需内存大小在类加载完成后已确定
- **分配方式**：
  - **指针碰撞**：如果堆内存规整，通过移动指针分配内存
  - **空闲列表**：如果堆内存不规整，通过空闲列表分配内存

- **线程安全**：
  - 采用CAS（Compare-And-Swap）机制保证线程安全
  - 或使用TLAB（Thread Local Allocation Buffer）为每个线程预分配内存

#### 6.2.3 初始化零值

为对象的实例变量设置默认零值，确保对象在不赋初值的情况下也能使用。

#### 6.2.4 设置对象头

设置对象头信息，包括：

- 对象的运行时数据（哈希码、GC分代年龄等）
- 指向对象所属类元数据的指针
- 如有必要，设置偏向锁标志

#### 6.2.5 执行＜init＞方法

执行构造方法，为对象的实例变量赋予正确的初始值，完成对象的初始化。

### 6.3 对象初始化的顺序

对象初始化时，各部分的执行顺序为：

1. 父类静态变量和静态代码块
2. 子类静态变量和静态代码块
3. 父类实例变量和实例代码块
4. 父类构造方法
5. 子类实例变量和实例代码块
6. 子类构造方法 



## 7. 字节码技术

### 7.1 概述

字节码技术是JVM生态中的核心技术之一，它不仅是Java "一次编译，到处运行"理念的基础，也是许多高级特性和框架的实现基石。本章节将深入探讨字节码的本质、字节码增强技术及其应用场景。

### 7.2 字节码基础

#### 7.2.1 什么是字节码

字节码（Bytecode）是Java虚拟机的中间指令格式，存储在.class文件中，是连接Java源代码和机器码的桥梁。它具有以下特点：

- **平台无关性**：相同的字节码可以在不同平台的JVM上执行
- **紧凑性**：字节码指令长度固定为1字节，操作数长度可变
- **面向JVM**：设计为JVM易于解析和执行的格式

#### 7.2.2 字节码文件结构

.class文件是一种严格定义的二进制格式，主要包含以下结构：

| 结构 | 描述 | 作用 |
|------|------|------|
| 魔数 | 0xCAFEBABE | 标识.class文件格式 |
| 版本号 | 主版本号和次版本号 | 确保JVM兼容性 |
| 常量池 | 字面量和符号引用 | 存储类、方法、字段的名称和描述符 |
| 访问标志 | 类的访问权限和属性 | 标识public、final、abstract等修饰符 |
| 类索引 | 指向常量池的索引 | 确定类的全限定名 |
| 父类索引 | 指向常量池的索引 | 确定父类的全限定名 |
| 接口索引表 | 指向常量池的索引集合 | 确定实现的接口 |
| 字段表集合 | 字段信息 | 描述类的字段 |
| 方法表集合 | 方法信息 | 描述类的方法，包含Code属性存储字节码指令 |
| 属性表集合 | 附加信息 | 存储类的额外属性 |

#### 7.2.3 JVM执行模型

JVM采用基于栈的执行模型，与基于寄存器的模型相比，具有更好的跨平台性：

- **栈帧**：每个方法执行时创建一个栈帧，包含局部变量表、操作数栈、动态链接和方法返回地址
- **局部变量表**：存储方法参数和局部变量
- **操作数栈**：用于方法执行过程中的计算
- **字节码执行**：JVM解释器或JIT编译器执行字节码指令，操作数栈用于传递参数和接收返回值

### 7.3 字节码增强技术

#### 7.3.1 核心概念

字节码增强是一类对现有字节码进行修改或动态生成全新字节码文件的技术，它允许在不修改源代码的情况下改变类的行为。

#### 7.3.2 主流实现技术

| 技术 | 核心思想 | 优点 | 缺点 | 适用场景 |
|------|---------|------|------|----------|
| ASM | 基于访问者模式，直接操作JVM指令 | 性能极高，功能强大 | 学习曲线陡峭，代码可读性差 | 对性能有极致要求的框架底层 |
| Javassist | 提供源码级API，使用字符串编程 | 易于上手，开发效率高 | 性能低于ASM，复杂字节码操作受限 | 快速原型开发，对性能要求不极致的场景 |
| Java Agent | 通过Instrumentation API实现无侵入增强 | 生产级应用的主要方式，支持运行时增强 | 实现复杂度较高 | APM工具，在线诊断工具 |

#### 7.3.3 ASM核心API

- **ClassReader**：读取字节码文件，解析为内部表示
- **ClassWriter**：生成或修改字节码，输出为字节数组
- **ClassVisitor**：访问类结构，可修改类的各个部分
- **MethodVisitor**：访问方法结构，可修改方法体的字节码指令

#### 7.3.4 Javassist核心类

- **ClassPool**：CtClass对象的容器，管理类的定义
- **CtClass**：类的抽象表示，可修改类的结构
- **CtMethod**：方法的抽象表示，可修改方法体
- **CtField**：字段的抽象表示，可添加或修改字段

#### 7.3.5 Java Agent实现步骤

1. **编写Agent类**：实现premain（启动时加载）或agentmain（运行时加载）方法
2. **实现ClassFileTransformer**：定义字节码转换逻辑
3. **注册Transformer**：通过Instrumentation.addTransformer()注册转换器
4. **打包配置**：在MANIFEST.MF中指定Premain-Class或Agent-Class
5. **加载Agent**：使用-javaagent参数启动或通过Attach API动态加载

### 7.4 应用场景

#### 7.4.1 框架开发

- **Spring AOP**：通过CGLIB（基于ASM）实现方法拦截
- **MyBatis**：动态生成Mapper接口的实现类
- **Lombok**：编译时生成getter、setter、构造方法等

#### 7.4.2 应用性能监控（APM）

- **SkyWalking**：无侵入地收集方法调用链和性能数据
- **Pinpoint**：跟踪分布式系统的调用链路
- **New Relic**：监控应用性能和健康状态

#### 7.4.3 在线诊断与热部署

- **Arthas**：基于Java Agent实现的在线诊断工具
- **JRebel**：实现Java代码的热部署，提高开发效率
- **Btrace**：动态插入调试代码，无需重启应用

#### 7.4.4 安全增强

- **字节码加密**：保护核心代码不被反编译
- **运行时监控**：检测并防止恶意代码执行
- **权限控制**：增强方法的访问控制

### 7.5 优缺点分析

#### 7.5.1 优点

1. **无侵入性**：无需修改源代码，符合"开闭原则"
2. **灵活性高**：可在程序生命周期的不同阶段进行干预
3. **功能强大**：能够实现传统编码难以或无法实现的功能
4. **性能优化**：可针对特定场景优化字节码，提高执行效率

#### 7.5.2 缺点与风险

1. **技术门槛高**：需要深入理解JVM字节码、类文件结构和类加载机制
2. **调试困难**：增强后的字节码难以直接调试，问题定位复杂
3. **兼容性风险**：不同JVM版本的字节码细节可能有差异
4. **性能影响**：不当的增强会增加方法调用开销和内存占用
5. **稳定性风险**：错误的字节码修改可能导致JVM验证失败或程序崩溃

### 7.6 最佳实践

#### 7.6.1 设计原则

- **最小化影响**：只增强必要的类和方法，注入最精简的代码
- **保持兼容性**：确保增强后的类与原类接口一致
- **异常处理**：增强代码应正确处理异常，不破坏原有逻辑
- **性能考虑**：选择合适的字节码操作库，平衡开发效率和运行性能

#### 7.6.2 实施建议

1. **充分测试**：在目标环境进行全面测试，包括功能、性能和压力测试
2. **监控与回滚**：生产环境中实施字节码增强时，应有监控和回滚机制
3. **版本管理**：对增强逻辑进行版本管理，便于追踪和调试
4. **文档完善**：详细记录增强逻辑和实现细节，便于后续维护

#### 7.6.3 工具推荐

- **ASM Bytecode Outline**：Eclipse插件，可视化字节码结构
- **Bytecode Viewer**：反编译和分析字节码的工具
- **JClassLib**：Java类文件浏览器和字节码编辑器
- **Arthas**：在线诊断和字节码增强工具

### 7.7 总结

字节码技术是JVM生态中的重要组成部分，它不仅是Java跨平台能力的基础，也是许多高级特性和框架的实现手段。通过字节码增强技术，我们可以在不修改源代码的情况下改变类的行为，实现无侵入的监控、AOP、热部署等功能。

虽然字节码技术具有较高的技术门槛和一定的风险，但在正确使用的情况下，它可以为我们的应用带来巨大的价值。随着JVM技术的不断发展，字节码技术也在不断演进，为Java生态系统注入新的活力。



## 8. 内存分配方式

### 8.1 指针碰撞（Bump the Pointer）

**适用场景**：当Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边。

**分配过程**：
- 中间有一个指针作为分界点的指示器
- 分配内存时，只需将指针向空闲空间方向挪动一段与对象大小相等的距离

**优点**：

- 分配速度快，只需移动指针
- 实现简单

### 8.2 空闲列表（Free List）

**适用场景**：当Java堆中的内存不规整，已使用的内存和空闲的内存相互交错。

**分配过程**：
- 虚拟机维护一个列表，记录哪些内存块是可用的
- 分配时，从列表中找到一块足够大的空间划分给对象实例
- 更新列表上的记录，标记已分配的内存

**优点**：
- 可以处理内存碎片问题
- 适用于内存使用频繁、对象大小不一的场景

### 8.3 线程安全的内存分配

由于堆是线程共享的，内存分配过程中需要考虑线程安全问题。JVM采用以下两种方式保证线程安全：

#### 8.3.1 CAS机制

- 使用CAS（Compare-And-Swap）操作配合失败重试机制，保证内存分配的原子性
- 适用于内存分配频繁的场景

#### 8.3.2 TLAB（Thread Local Allocation Buffer）

- 为每个线程预分配一块独立的内存区域
- 线程在自己的TLAB中分配内存，不需要加锁
- 只有当TLAB用完需要重新分配时，才需要进行CAS操作
- 提高了内存分配的效率

### 8.4 内存分配策略

1. **对象优先在Eden区分配**：大多数对象在Eden区创建

2. **大对象直接进入老年代**：超过一定大小的对象直接分配到老年代

   **参数设置**：
   - `-XX:PretenureSizeThreshold`：设置大对象阈值，单位为字节
   - 示例：`-XX:PretenureSizeThreshold=3145728`（3MB）

   **默认值**：
   - 不同JVM实现可能不同，通常默认值为0，表示不启用此功能
   - 需要注意的是，此参数仅对Serial和ParNew收集器有效，对Parallel Scavenge收集器无效

   **验证方法**：
   1. **GC日志验证**：
      - 添加参数 `-XX:+PrintGCDetails -XX:+PrintGCDateStamps`
      - 观察GC日志中是否有大对象直接分配到老年代的记录
   2. **内存分析工具**：
      - 使用jmap生成堆转储文件：`jmap -dump:format=b,file=heap.hprof <pid>`
      - 使用MAT（Memory Analyzer Tool）分析堆转储，查看大对象的分配位置
   3. **代码验证**：
      ```java
      public class LargeObjectTest {
          public static void main(String[] args) {
              // 分配一个超过阈值的大对象
              byte[] largeObject = new byte[4 * 1024 * 1024]; // 4MB
              System.out.println("Allocated large object");
              // 保持程序运行，便于观察
              try {
                  Thread.sleep(60000);
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
          }
      }
      ```

   **注意事项**：
   - 阈值设置过小会导致大量对象直接进入老年代，可能触发频繁的Full GC
   - 阈值设置过大可能导致大对象在新生代分配，增加Minor GC的压力
   - 仅对Serial和ParNew收集器有效，Parallel Scavenge收集器使用自己的策略
   - 对于G1收集器，大对象会被分配到Humongous区域，而不是直接进入老年代

   **优点**：
   - 减少新生代的内存碎片
   - 避免大对象在新生代和老年代之间频繁复制，减少GC开销

   **缺点**：
   - 可能导致老年代过早被填满，触发Full GC
   - 需要根据应用特点调整阈值，否则可能影响性能

3. **长期存活的对象进入老年代**：对象年龄达到阈值后进入老年代

4. **动态对象年龄判断**：如果Survivor区中相同年龄的对象总和超过一半，年龄大于等于该年龄的对象直接进入老年代

5. **空间分配担保**：Minor GC前，检查老年代剩余空间是否足够容纳新生代所有对象，如果不足，可能会提前触发Full GC 



## 9. GC 名词概念

### 9.1 垃圾回收的类型

根据回收范围的不同，垃圾回收可以分为以下几种类型：

| 类型 | 描述 | 回收范围 |
|------|------|----------|
| **部分收集（Partial GC）** | 只回收部分堆空间 | 新生代或老年代 |
| **新生代收集（Young GC/Minor GC）** | 只回收新生代 | Eden区、Survivor区 |
| **老年代收集（Major GC/Old GC）** | 只回收老年代 | 老年代 |
| **整堆收集（Full GC）** | 回收整个堆空间 | 新生代、老年代、元空间 |

### 9.2 垃圾回收的触发条件

#### 9.2.1 Minor GC触发条件

- **Eden区空间不足**：当新对象分配时，Eden区空间不足
- **大对象直接进入老年代**：当分配的对象超过Eden区大小

#### 9.2.2 Major GC触发条件

- **老年代空间不足**：当对象从新生代晋升到老年代时，老年代空间不足
- **元空间不足**：当元空间空间不足时

#### 9.2.3 Full GC触发条件

- **调用System.gc()**：显式触发Full GC
- **老年代空间不足**：当Major GC无法释放足够空间
- **空间分配担保失败**：Minor GC前，老年代剩余空间不足以容纳新生代所有对象
- **CMS收集器并发失败**：CMS收集器在并发阶段无法处理所有垃圾

### 9.3 垃圾回收的性能指标

- **吞吐量**：CPU用于执行用户代码的时间占总时间的比例
- **停顿时间**：垃圾回收期间应用程序暂停的时间
- **内存占用**：垃圾回收器本身需要的内存开销
- **回收频率**：垃圾回收发生的频率

### 9.4 垃圾回收的常见问题

- **频繁GC**：可能由内存泄漏、对象创建过快等原因导致
- **Full GC时间过长**：可能由老年代空间不足、大对象过多等原因导致
- **内存碎片**：可能由标记-清除算法导致，影响内存分配效率



## 10. GC Root

### 10.1 基本概念

GC Root（Garbage Collection Root）是指在Java虚拟机中被直接引用的对象集合，它们被认为是存活对象，不能被垃圾回收器回收。

### 10.2 GC Root的类型

| 类型 | 描述 | 示例 |
|------|------|------|
| **虚拟机栈中引用的对象** | 栈帧中局部变量表和操作数栈中引用的对象 | 方法参数、局部变量 |
| **方法区中类静态属性引用的对象** | 类的静态字段引用的对象 | `static Object obj = new Object()` |
| **方法区中常量引用的对象** | 常量池中的引用类型常量 | `static final Object obj = new Object()` |
| **Native方法中引用的对象** | 本地方法中引用的Java对象 | JNI调用中的对象引用 |
| **活动线程中的对象** | 当前正在执行的线程对象 | 线程对象本身 |
| **当前类加载器加载的类的对象** | 类加载器引用的类对象 | 加载的类的Class对象 |
| **锁对象** | 被synchronized持有的对象 | `synchronized(obj) { ... }`中的obj |
| **JVM内部对象** | JVM自身使用的对象 | 类加载器、系统类等 |

### 10.3 GC Root的作用

GC Root为垃圾回收器提供了初始的扫描位置，垃圾回收过程如下：

1. **标记阶段**：从GC Root开始，标记所有可达的对象
2. **清除阶段**：回收所有未被标记的对象

### 10.4 GC Root的特点

- **存活对象**：GC Root本身是存活对象，不会被回收
- **动态变化**：GC Root集合会随着程序执行而动态变化
- **扫描起点**：垃圾回收器的扫描过程必须从GC Root开始

### 10.5 可达性分析

可达性分析是垃圾回收的核心算法，其过程如下：

1. **确定GC Root**：识别所有的GC Root对象
2. **标记可达对象**：从GC Root开始，递归标记所有可达的对象
3. **回收不可达对象**：回收所有未被标记的对象

通过可达性分析，垃圾回收器能够准确识别哪些对象是存活的，哪些对象是可以被回收的，从而实现高效的内存回收。



## 11. 三色标记

### 11.1 基本概念

三色标记（Tri-color Marking）是一种用于并发可达性分析的算法，通过三种颜色标记对象的状态：

| 颜色 | 含义 |
|------|------|
| **白色** | 对象尚未被垃圾收集器访问过。分析开始时所有对象都是白色，分析结束后仍为白色的对象表示不可达，将被回收。 |
| **黑色** | 对象已经被垃圾收集器访问过，且其所有引用都已扫描完毕。黑色对象是安全存活的，不需要重新扫描。 |
| **灰色** | 对象已经被垃圾收集器访问过，但至少有一个引用尚未被扫描。灰色对象是分析过程中的中间状态。 |

### 11.2 工作原理

可达性分析的扫描过程可以看作是一股以灰色为波峰的波纹从黑向白推进的过程：

1. **初始状态**：所有对象都是白色
2. **标记根对象**：将GC Root标记为灰色
3. **扫描过程**：
   - 取出一个灰色对象，标记为黑色
   - 扫描其所有引用，将引用的对象标记为灰色
   - 重复此过程，直到没有灰色对象
4. **结束状态**：所有白色对象都是不可达的，将被回收

### 11.3 并发标记的问题

在并发标记过程中，由于用户线程仍在运行，可能会导致"对象消失"的问题：

#### 11.3.1 对象消失的场景

1. **场景一**：黑色对象指向新的白色对象
   - 黑色对象A新建了对白色对象B的引用
   - 由于A已经是黑色，不会被重新扫描，导致B无法被标记

2. **场景二**：灰色对象断开对白色对象的引用
   - 灰色对象C断开了对白色对象D的引用
   - 同时，黑色对象E新建了对D的引用
   - 由于C仍在扫描中，可能导致D被错误回收

### 11.4 解决方案

为了解决并发标记中的对象消失问题，JVM采用了以下两种方案：

#### 11.4.1 增量更新（Incremental Update）

- **原理**：当黑色对象新建对白色对象的引用时，将黑色对象重新标记为灰色
- **适用**：CMS收集器采用此方案

#### 11.4.2 原始快照（Snapshot At The Beginning, SATB）

- **原理**：在并发标记开始时创建一个快照，记录所有可达对象
- **适用**：G1收集器采用此方案

### 11.5 三色标记的优势

- **支持并发标记**：减少STW时间，提高应用响应速度
- **标记效率高**：通过颜色区分对象状态，避免重复扫描
- **为现代垃圾收集器奠定基础**：G1、ZGC等先进收集器都基于此算法

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0f6395054ae42a0998c33eea98b8b2a~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1095&h=1155&s=442276&e=png&b=fdfdfd)



## 12. 垃圾回收算法

### 12.1 标记-清除算法

**核心思想**：标记-清除算法是最基础的垃圾收集算法，将垃圾回收分为两个阶段：

1. **标记阶段**：遍历所有对象，标记出需要回收的对象
2. **清除阶段**：回收被标记对象所占用的内存空间

**适用场景**：
- 适用于对象存活率低的场景，如老年代的部分回收
- 适用于对内存碎片不敏感的应用

**优点**：
- 实现简单，不需要移动对象
- 对于大量对象需要回收的场景，效率较高

**缺点**：
- 标记和清除过程效率较低，需要遍历所有对象
- 产生大量不连续的内存碎片，可能导致后续大对象分配失败
- 碎片过多会增加垃圾回收的频率

**工作原理**：
标记-清除算法会标记所有死亡的对象，然后清除它们，留下的存活对象和空闲空间会交错分布，形成内存碎片。

![](https://developer.qcloudimg.com/http-save/9862454/eeeb7395bf13a35400741797f3048283.png)

### 12.2 复制算法

**核心思想**：复制算法将内存空间划分为两个相等的区域，每次只使用其中一个。垃圾收集时，将当前区域中的存活对象复制到另一个区域，然后清除整个当前区域。

**适用场景**：
- 适用于对象存活率低的场景，如新生代的回收
- 适用于对内存分配效率要求高的应用

**优点**：
- 实现简单，运行高效
- 按顺序分配内存，不需要考虑内存碎片
- 内存分配速度快，只需指针碰撞即可

**缺点**：
- 可用内存缩小为原来的一半，空间利用率低
- 对象存活率高时会频繁进行复制操作，效率下降

**工作原理**：
复制算法通过将存活对象复制到新区域，然后清空原区域，避免了内存碎片问题。在新生代中，通常将内存分为Eden区和两个Survivor区，比例为8:1:1，每次只使用Eden和一个Survivor区，这样空间利用率可达90%。

![](https://developer.qcloudimg.com/http-save/9862454/cefd4fa40aabbeea1ffe46b7a4576141.png)

### 12.3 标记-整理算法

**核心思想**：标记-整理算法结合了标记-清除和复制算法的优点，分为三个阶段：

1. **标记阶段**：标记出需要回收的对象
2. **整理阶段**：将所有存活对象压缩到内存的一端，紧凑排列
3. **清除阶段**：清理边界以外的内存空间

**适用场景**：
- 适用于对象存活率高的场景，如老年代的回收
- 适用于对内存碎片敏感的应用

**优点**：
- 解决了标记-清除算法的内存碎片问题
- 空间利用率高，不需要额外的内存空间

**缺点**：
- 需要移动对象，一定程度上降低了效率
- 整理过程中需要暂停用户线程（STW）

**工作原理**：
标记-整理算法通过移动存活对象，使它们紧凑排列，然后清理边界外的内存，既避免了内存碎片，又提高了空间利用率。

![](https://developer.qcloudimg.com/http-save/9862454/9c6691059a9a8fb2e60393aeaa7009e5.png)

### 12.4 分代收集算法

**核心思想**：分代收集算法根据对象的生命周期将内存划分为不同区域，对不同区域采用不同的垃圾收集策略。

**适用场景**：
- 几乎所有现代JVM的默认垃圾收集策略
- 适用于大多数Java应用

**优点**：
- 根据对象特点采用不同策略，提高回收效率
- 减少Full GC的频率，提高应用性能
- 针对性强，优化效果明显

**工作原理**：
1. **新生代**：对象存活率低，采用复制算法，分为Eden区和两个Survivor区
2. **老年代**：对象存活率高，采用标记-清除或标记-整理算法
3. **元空间**：存储类信息，采用专门的回收策略

通过分代收集，Minor GC（新生代回收）频率高但速度快，Major GC（老年代回收）频率低但耗时较长，平衡了回收效率和应用性能。

### 12.5 垃圾回收算法对比

| 算法 | 适用场景 | 优点 | 缺点 |
|------|----------|------|------|
| 标记-清除 | 老年代、对象存活率低 | 实现简单、不需要移动对象 | 产生内存碎片、效率较低 |
| 复制 | 新生代、对象存活率低 | 无内存碎片、分配速度快 | 空间利用率低、对象存活率高时效率下降 |
| 标记-整理 | 老年代、对象存活率高 | 无内存碎片、空间利用率高 | 需要移动对象、效率较低 |
| 分代收集 | 全堆 | 针对性强、效率高 | 实现复杂 |



## 13. 垃圾回收器

### 13.1 垃圾回收器概述

垃圾回收器是JVM中负责执行垃圾回收的组件，不同的垃圾回收器采用不同的算法和策略，适用于不同的应用场景。根据回收线程的数量和执行方式，垃圾回收器可以分为以下几类：

| 类型 | 特点 | 适用场景 |
|------|------|----------|
| **串行收集器** | 单线程执行垃圾回收 | 单核CPU环境、客户端应用 |
| **并行收集器** | 多线程执行垃圾回收 | 多核CPU环境、对吞吐量要求高的应用 |
| **并发收集器** | 与用户线程并发执行垃圾回收 | 对延迟要求高的应用、服务器应用 |
| **增量收集器** | 将垃圾回收分解为多个小步骤 | 实时应用、对响应时间要求高的场景 |

### 13.2 Serial收集器

**背景**：Serial收集器是最古老、最基本的垃圾收集器，也是JVM客户端模式下的默认收集器。

**特点**：
- 单线程执行垃圾回收，只使用一个CPU核心
- 新生代采用复制算法，老年代采用标记-整理算法
- 执行过程中会暂停所有用户线程（STW）

**适用场景**：
- 适用于单核CPU环境
- 适用于内存较小的客户端应用
- 适用于对响应时间要求不高的场景

**优点**：
- 实现简单，代码量小
- 单线程执行，没有线程切换开销
- 在单核CPU环境下效率较高

**缺点**：
- 垃圾回收时会暂停所有用户线程，导致应用卡顿
- 在多核CPU环境下，无法充分利用硬件资源
- 不适用于大型服务器应用

### 13.3 Serial Old收集器

**背景**：Serial Old是Serial收集器的老年代版本，主要用于与其他收集器配合使用。

**特点**：
- 单线程执行老年代垃圾回收
- 采用标记-整理算法
- 执行过程中会暂停所有用户线程

**适用场景**：
- 作为CMS收集器的备选方案，当CMS收集失败时使用
- 在JDK 5之前与Parallel Scavenge收集器配合使用
- 适用于小型应用或客户端环境

### 13.4 ParNew收集器

**背景**：ParNew是Serial收集器的并行版本，主要用于与CMS收集器配合使用。

**特点**：
- 多线程执行新生代垃圾回收
- 新生代采用复制算法
- 执行过程中会暂停所有用户线程

**适用场景**：
- 适用于多核CPU环境
- 与CMS收集器配合使用，作为新生代收集器
- 适用于对响应时间有一定要求的服务器应用

**优点**：
- 多线程执行，充分利用多核CPU资源
- 与CMS收集器兼容性好
- 新生代回收速度快

**缺点**：
- 垃圾回收时会暂停所有用户线程
- 线程数量过多时，线程切换开销会影响性能

### 13.5 Parallel Scavenge收集器

**背景**：Parallel Scavenge是一款专注于吞吐量的并行收集器，也称为"吞吐量优先收集器"。

**特点**：
- 多线程执行垃圾回收
- 新生代采用复制算法，老年代采用标记-整理算法
- 执行过程中会暂停所有用户线程
- 支持自适应调节策略，可以根据系统运行情况自动调整内存分配和回收策略

**适用场景**：
- 适用于多核CPU环境
- 适用于对吞吐量要求较高的应用，如科学计算、批处理任务
- 适用于后台服务，对响应时间要求不高的场景

**优点**：
- 高吞吐量，适合计算密集型应用
- 自适应调节能力强，减少人工调优成本
- 多线程执行，充分利用硬件资源

**缺点**：
- 垃圾回收时会暂停所有用户线程
- 对响应时间敏感的应用不友好

### 13.6 Parallel Old收集器

**背景**：Parallel Old是Parallel Scavenge收集器的老年代版本，在JDK 6中引入。

**特点**：
- 多线程执行老年代垃圾回收
- 采用标记-整理算法
- 执行过程中会暂停所有用户线程

**适用场景**：
- 与Parallel Scavenge收集器配合使用，组成"Parallel Scavenge + Parallel Old"的收集器组合
- 适用于对吞吐量要求较高的应用

### 13.7 CMS收集器

**背景**：CMS（Concurrent Mark Sweep）收集器是一款以低延迟为目标的并发收集器，在JDK 5中引入。

**特点**：
- 并发执行垃圾回收，减少STW时间
- 老年代采用标记-清除算法
- 执行过程分为四个阶段：初始标记、并发标记、重新标记、并发清除

**适用场景**：
- 适用于对响应时间要求较高的应用，如Web服务器、电子商务系统
- 适用于多核CPU环境
- 适用于内存较大的服务器应用

**优点**：
- 并发执行，减少STW时间，提高应用响应速度
- 适用于对延迟敏感的应用

**缺点**：
- 采用标记-清除算法，会产生内存碎片
- 对CPU资源敏感，并发执行时会占用部分CPU资源
- 无法处理浮动垃圾，可能导致并发失败
- 老年代空间不足时会触发Full GC，导致长时间STW

### 13.8 G1收集器

#### 基本特色

G1（Garbage First）收集器是JDK 7中引入的一款面向服务端应用的垃圾收集器，在JDK 9中成为默认收集器。

**特点**：
- 分区收集：将堆内存划分为多个大小相等的区域（Region）
- 并发标记：与CMS类似，支持并发标记
- 增量压缩：只对部分区域进行压缩，减少STW时间
- 可预测的停顿时间：通过设置停顿时间目标，控制垃圾回收的时间
- 混合回收：同时回收新生代和老年代的部分区域

**适用场景**：
- 适用于大内存服务器应用，堆大小可达数GB甚至数十GB
- 适用于对响应时间要求较高的应用
- 适用于需要可预测停顿时间的场景

**优点**：
- 可预测的停顿时间，满足延迟敏感应用的需求
- 高吞吐量，适合大内存环境
- 减少内存碎片，提高内存利用率
- 灵活的回收策略，可根据应用特点调整

**缺点**：
- 实现复杂，内存开销较大
- 对于小内存环境，性能可能不如其他收集器
- 并发执行时会占用部分CPU资源

### 13.9 ZGC收集器

**背景**：ZGC（Z Garbage Collector）是JDK 11中引入的一款低延迟垃圾收集器，旨在实现亚毫秒级的垃圾回收停顿时间。

**特点**：
- 并发执行：几乎所有阶段都与用户线程并发执行
- 基于Region：将堆内存划分为多个Region
- 着色指针：使用指针压缩技术，支持更大的堆内存
- 读屏障：通过读屏障实现并发标记和并发重定位
- 无内存碎片：采用复制算法，自动整理内存

**适用场景**：
- 适用于超大内存环境，堆大小可达数TB
- 适用于对延迟要求极高的应用，如金融交易系统、实时控制系统
- 适用于需要处理大量数据的服务器应用

**优点**：
- 极低的停顿时间，通常在1毫秒以内
- 支持超大堆内存，最大可达16TB
- 无内存碎片，提高内存利用率
- 吞吐量与停顿时间的平衡较好

**缺点**：
- 内存开销较大，需要额外的内存用于标记和重定位
- 对CPU资源要求较高
- 实现复杂，维护成本高

### 13.10 Shenandoah收集器

**背景**：Shenandoah是Red Hat开发的一款低延迟垃圾收集器，在JDK 12中成为正式特性。

**特点**：
- 并发执行：与ZGC类似，支持几乎所有阶段的并发执行
- 基于Region：将堆内存划分为多个Region
- 转发指针：使用转发指针技术，支持并发重定位
- 读屏障：通过读屏障实现并发标记和并发重定位
- 无内存碎片：采用复制算法，自动整理内存

**适用场景**：
- 适用于大内存环境，堆大小可达数十GB
- 适用于对延迟要求较高的应用
- 适用于需要平衡吞吐量和延迟的场景

**优点**：
- 低停顿时间，通常在毫秒级别
- 支持大堆内存
- 无内存碎片，提高内存利用率
- 对CPU资源的要求相对较低

**缺点**：
- 内存开销较大
- 实现复杂，维护成本高
- 在某些场景下吞吐量可能不如其他收集器

### 13.11 垃圾回收器选择建议

| 应用场景 | 推荐收集器 | JVM参数 |
|----------|------------|---------|
| 客户端应用 | Serial | `-XX:+UseSerialGC` |
| 计算密集型应用 | Parallel Scavenge + Parallel Old | `-XX:+UseParallelGC -XX:+UseParallelOldGC` |
| 响应时间敏感应用 | CMS | `-XX:+UseConcMarkSweepGC -XX:+UseParNewGC` |
| 大内存服务器应用 | G1 | `-XX:+UseG1GC -XX:MaxGCPauseMillis=200` |
| 超大内存低延迟应用 | ZGC | `-XX:+UseZGC` |



## 14. GC执行过程与日志分析

### 14.1 GC执行流程图

以下是GC执行的详细流程：

```mermaid
flowchart TD
    A[程序运行] --> B{内存分配请求}
    B -->|Eden区有空间| C[分配内存]
    B -->|Eden区无空间| D[触发Minor GC]
    D --> E[回收Eden区]
    E --> F{Survivor区是否有空间}
    F -->|有空间| G[将存活对象移至Survivor区]
    F -->|无空间| H[将存活对象移至老年代]
    G --> I{对象年龄是否达到阈值}
    I -->|是| J[移至老年代]
    I -->|否| K[继续在Survivor区]
    J --> L{老年代是否有空间}
    H --> L
    L -->|有空间| M[完成GC]
    L -->|无空间| N[触发Major GC/Full GC]
    N --> O{回收后是否有空间}
    O -->|有空间| P[完成GC]
    O -->|无空间| Q[抛出OutOfMemoryError]
    M --> R[继续程序运行]
    P --> R
    Q --> S[程序终止]
```

### 14.2 完整GC执行流程

1. **对象分配**：当新对象产生时，首先会判断Eden区是否有内存空间，如果有，则直接将新对象保存在Eden区。

2. **Minor GC触发**：如果Eden区内存不足，会自动执行Minor GC操作，清理Eden区的无用内存空间。

3. **存活对象处理**：
   - Minor GC后，如果Eden区内存仍不足，会检查Survivor区是否有剩余空间
   - 如果Survivor区有空间，将Eden区部分活跃对象保存在Survivor区
   - 如果Survivor区也没有空间，则将部分存活对象保存在老年代

4. **Major GC/Full GC触发**：如果老年代也满了，会触发Major GC（或Full GC），进行老年代的清理。

5. **OOM异常**：如果老年代执行Full GC后，无法进行对象的保存，则会产生OutOfMemoryError异常。

通过这个流程，JVM实现了自动的内存管理，确保了Java应用的内存使用效率和稳定性。

### 14.3 分代执行过程

#### 14.3.1 内存分配比例
- **新生代**：默认占总堆空间的1/3，包含Eden区和两个Survivor区（From和To），默认比例为8:1:1。
- **老年代**：默认占总堆空间的2/3，存放存活时间较长的对象。

#### 14.3.2 Minor GC执行过程
当Eden区内存不足时，触发Minor GC：

1. **第一次GC**：在Eden区执行GC，存活的对象会被移动到其中一个Survivor分区。

2. **后续GC**：采用复制算法，将Eden和From Survivor区一起清理，存活的对象会被复制到To Survivor区。

3. **对象年龄增长**：对象每移动一次，年龄加1，当对象年龄大于阈值（默认15）时，直接移动到老年代。

4. **动态年龄判断**：如果Survivor区中相同年龄的对象总和超过Survivor区大小的50%（可通过-XX:TargetSurvivorRatio调整），则年龄大于等于该年龄的对象直接进入老年代。

5. **空间分配担保**：如果Survivor区内存不足，会使用老年代空间作为担保。

6. **大对象直接进入老年代**：超过指定大小的对象（可通过-XX:PretenureSizeThreshold调整）可以直接进入老年代。

### 14.4 GC日志分析

#### 14.4.1 GC日志格式

不同的垃圾收集器产生的日志格式略有不同，以下是常见的GC日志格式：

**Parallel Scavenge收集器日志**：
```
[GC (Allocation Failure) [PSYoungGen: 76800K->10240K(89600K)] 76800K->14336K(294400K), 0.0087359 secs] [Times: user=0.02 sys=0.00, real=0.01 secs]
[Full GC (Ergonomics) [PSYoungGen: 10240K->0K(89600K)] [ParOldGen: 4096K->13881K(204800K)] 14336K->13881K(294400K), [Metaspace: 3465K->3465K(1056768K)], 0.0147439 secs] [Times: user=0.04 sys=0.00, real=0.01 secs]
```

**CMS收集器日志**：
```
[GC (Allocation Failure) [ParNew: 8192K->1024K(9216K), 0.0038473 secs] 8192K->3072K(29696K), 0.0038842 secs] [Times: user=0.01 sys=0.00, real=0.00 secs]
[GC (CMS Initial Mark) [1 CMS-initial-mark: 2048K(20480K)] 5120K(29696K), 0.0006887 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
[GC (CMS Concurrent Mark) [CMS-concurrent-mark: 0.0027361 secs] [Times: user=0.01 sys=0.00, real=0.00 secs]
[GC (CMS Concurrent Preclean) [CMS-concurrent-preclean: 0.0006583 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
[GC (CMS Final Remark) [YG occupancy: 1024 K (9216 K)] [Rescan (parallel) , 0.0005068 secs] [weak refs processing, 0.0000147 secs] [class unloading, 0.0003157 secs] [scrub symbol table, 0.0003065 secs] [scrub string table, 0.0001239 secs] [1 CMS-remark: 2048K(20480K)] 3072K(29696K), 0.0013749 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
[GC (CMS Concurrent Sweep) [CMS-concurrent-sweep: 0.0015857 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
[GC (CMS Concurrent Reset) [CMS-concurrent-reset: 0.0005637 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
```

**G1收集器日志**：
```
[GC pause (G1 Evacuation Pause) (young), 0.0032458 secs] [Eden: 8192K->0K(8192K) Survivors: 0K->1024K Heap: 8192K->1536K(32768K)] [Times: user=0.01 sys=0.00, real=0.00 secs]
[GC pause (G1 Evacuation Pause) (mixed), 0.0045678 secs] [Eden: 8192K->0K(8192K) Survivors: 1024K->1024K Heap: 16384K->8192K(32768K)] [Times: user=0.01 sys=0.00, real=0.00 secs]
```

#### 14.4.2 关键信息解读

- **GC类型**：Allocation Failure（分配失败）、Ergonomics（自动调优）、CMS Initial Mark（CMS初始标记）等
- **内存区域**：PSYoungGen（Parallel Scavenge新生代）、ParOldGen（Parallel Old老年代）、Metaspace（元空间）等
- **内存变化**：如76800K->10240K，表示GC前内存使用量->GC后内存使用量
- **内存大小**：如(89600K)，表示该内存区域的总大小
- **GC时间**：如0.0087359 secs，表示GC执行的时间
- **时间分解**：user（用户